"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[792],{52325:function(ab,c,b){var ac=b(48764).Buffer;Object.defineProperty(c,"__esModule",{value:!0});var h=b(42223),a=b(80496),i=b(67060),j=(b(67462),b(42474)),k=b(67172),ad=b(95131),ae=b(4285),l=b(37083),m=b(91094);function d(a){return a&&"object"==typeof a&&"default"in a?a:{default:a}}function e(a){if(a&&a.__esModule)return a;var b=Object.create(null);return a&&Object.keys(a).forEach(function(c){if("default"!==c){var d=Object.getOwnPropertyDescriptor(a,c);Object.defineProperty(b,c,d.get?d:{enumerable:!0,get:function(){return a[c]}})}}),b.default=a,Object.freeze(b)}var af=e(h),ag=d(i),ah=d(j),ai=e(k),aj=d(l),f=d(m);a.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),a.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");let ak=a.Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),al=a.Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function am(b){let c;if(a.Scalar.eq(b,al))c=await a.buildBn128();else if(a.Scalar.eq(b,ak))c=await a.buildBls12381();else throw Error(`Curve not supported: ${a.Scalar.toString(b)}`);return c}async function an(c){var d;let b,e=(d=c,d.toUpperCase().match(/[A-Za-z0-9]+/g).join(""));if(["BN128","BN254","ALTBN128"].indexOf(e)>=0)b=await a.buildBn128();else if(["BLS12381"].indexOf(e)>=0)b=await a.buildBls12381();else throw Error(`Curve not supported: ${c}`);return b}function ao(a){return((4294901760&a)!=0?(a&=4294901760,16):0)|((4278255360&a)!=0?(a&=4278255360,8):0)|((4042322160&a)!=0?(a&=4042322160,4):0)|((3435973836&a)!=0?(a&=3435973836,2):0)|(2863311530&a)!=0}function ap(d,e){let f=new DataView(d.buffer,d.byteOffset,d.byteLength),a="";for(let b=0;b<4;b++){b>0&&(a+="\n"),a+="		";for(let c=0;c<4;c++)c>0&&(a+=" "),a+=f.getUint32(16*b+4*c).toString(16).padStart(8,"0")}return e&&(a=e+"\n"+a),a}function aq(b,c){if(b.byteLength!=c.byteLength)return!1;for(var d=new Int8Array(b),e=new Int8Array(c),a=0;a!=b.byteLength;a++)if(d[a]!=e[a])return!1;return!0}function ar(b){let c=b.getPartialHash(),a=ag.default(64);return a.setPartialHash(c),a}async function g(a,b,c,d,e){if(a.G1.isZero(b)||a.G1.isZero(c)||a.G2.isZero(d)||a.G2.isZero(e))return!1;let f=await a.pairingEq(b,e,a.G1.neg(c),d);return f}function as(){return window.prompt("Enter a random text. (Entropy): ","")}async function at(c){for(;!c;)c=await as();let d=ag.default(64);d.update(ah.default.randomBytes(64));let f=new TextEncoder;d.update(f.encode(c));let g=ac.from(d.digest()),e=[];for(let b=0;b<8;b++)e[b]=g.readUInt32BE(4*b);let h=new a.ChaCha(e);return h}function au(j,d){let e,f;d<32?(e=1<<d>>>0,f=1):(e=4294967296,f=1<<d-32>>>0);let b=j;for(let g=0;g<f;g++)for(let h=0;h<e;h++)b=ah.default.createHash("sha256").update(b).digest();let k=new DataView(b.buffer,b.byteOffset,b.byteLength),i=[];for(let c=0;c<8;c++)i[c]=k.getUint32(4*c,!1);let l=new a.ChaCha(i);return l}function av(a){return a instanceof Uint8Array?a:("0x"==a.slice(0,2)&&(a=a.slice(2)),new Uint8Array(a.match(/[\da-f]{2}/gi).map(function(a){return parseInt(a,16)})))}function aw(a){return Array.prototype.map.call(a,function(a){return("0"+(255&a).toString(16)).slice(-2)}).join("")}function ax(b,a){if(a instanceof Uint8Array)return b.toString(a);if(Array.isArray(a))return a.map(ax.bind(null,b));if("object"==typeof a){let c={},d=Object.keys(a);return d.forEach(d=>{c[d]=ax(b,a[d])}),c}if("bigint"==typeof a|| void 0!==a.eq)return a.toString(10);return a}async function ay(b,c){await af.startWriteSection(b,1),await b.writeULE32(1),await af.endWriteSection(b);let d=await am(c.q);await af.startWriteSection(b,2);let e=d.q,f=(Math.floor((a.Scalar.bitLength(e)-1)/64)+1)*8,g=d.r,h=(Math.floor((a.Scalar.bitLength(g)-1)/64)+1)*8;await b.writeULE32(f),await af.writeBigInt(b,e,f),await b.writeULE32(h),await af.writeBigInt(b,g,h),await b.writeULE32(c.nVars),await b.writeULE32(c.nPublic),await b.writeULE32(c.domainSize),await az(b,d,c.vk_alpha_1),await az(b,d,c.vk_beta_1),await aA(b,d,c.vk_beta_2),await aA(b,d,c.vk_gamma_2),await az(b,d,c.vk_delta_1),await aA(b,d,c.vk_delta_2),await af.endWriteSection(b)}async function az(c,a,d){let b=new Uint8Array(2*a.G1.F.n8);a.G1.toRprLEM(b,0,d),await c.write(b)}async function aA(c,a,d){let b=new Uint8Array(2*a.G2.F.n8);a.G2.toRprLEM(b,0,d),await c.write(b)}async function aB(c,a,d){let e=await c.read(2*a.G1.F.n8),b=a.G1.fromRprLEM(e,0);return d?a.G1.toObject(b):b}async function aC(c,a,d){let e=await c.read(2*a.G2.F.n8),b=a.G2.fromRprLEM(e,0);return d?a.G2.toObject(b):b}async function aD(a,b,c){await af.startReadUniqueSection(a,b,1);let d=await a.readULE32();if(await af.endReadSection(a),1==d)return await aE(a,b,c);if(2==d)return await aF(a,b,c);throw Error("Protocol not supported: ")}async function aE(b,f,c){let a={};a.protocol="groth16",await af.startReadUniqueSection(b,f,2);let d=await b.readULE32();a.n8q=d,a.q=await af.readBigInt(b,d);let e=await b.readULE32();return a.n8r=e,a.r=await af.readBigInt(b,e),a.curve=await am(a.q),a.nVars=await b.readULE32(),a.nPublic=await b.readULE32(),a.domainSize=await b.readULE32(),a.power=ao(a.domainSize),a.vk_alpha_1=await aB(b,a.curve,c),a.vk_beta_1=await aB(b,a.curve,c),a.vk_beta_2=await aC(b,a.curve,c),a.vk_gamma_2=await aC(b,a.curve,c),a.vk_delta_1=await aB(b,a.curve,c),a.vk_delta_2=await aC(b,a.curve,c),await af.endReadSection(b),a}async function aF(b,f,c){let a={};a.protocol="plonk",await af.startReadUniqueSection(b,f,2);let e=await b.readULE32();a.n8q=e,a.q=await af.readBigInt(b,e);let d=await b.readULE32();return a.n8r=d,a.r=await af.readBigInt(b,d),a.curve=await am(a.q),a.nVars=await b.readULE32(),a.nPublic=await b.readULE32(),a.domainSize=await b.readULE32(),a.power=ao(a.domainSize),a.nAdditions=await b.readULE32(),a.nConstrains=await b.readULE32(),a.k1=await b.read(d),a.k2=await b.read(d),a.Qm=await aB(b,a.curve,c),a.Ql=await aB(b,a.curve,c),a.Qr=await aB(b,a.curve,c),a.Qo=await aB(b,a.curve,c),a.Qc=await aB(b,a.curve,c),a.S1=await aB(b,a.curve,c),a.S2=await aB(b,a.curve,c),a.S3=await aB(b,a.curve,c),a.X_2=await aC(b,a.curve,c),await af.endReadSection(b),a}async function aG(p,e){let{fd:b,sections:d}=await af.readBinFile(p,"zkey",1),c=await aD(b,d,e),k=new a.F1Field(c.r),q=a.Scalar.mod(a.Scalar.shl(1,8*c.n8r),c.r),l=k.inv(q),C=k.mul(l,l),f=await am(c.q);await af.startReadUniqueSection(b,d,3),c.IC=[];for(let m=0;m<=c.nPublic;m++){let r=await aB(b,f,e);c.IC.push(r)}await af.endReadSection(b),await af.startReadUniqueSection(b,d,4);let s=await b.readULE32();c.ccoefs=[];for(let n=0;n<s;n++){let t=await b.readULE32(),u=await b.readULE32(),v=await b.readULE32(),w=await D();c.ccoefs.push({matrix:t,constraint:u,signal:v,value:w})}await af.endReadSection(b),await af.startReadUniqueSection(b,d,5),c.A=[];for(let g=0;g<c.nVars;g++){let x=await aB(b,f,e);c.A[g]=x}await af.endReadSection(b),await af.startReadUniqueSection(b,d,6),c.B1=[];for(let h=0;h<c.nVars;h++){let y=await aB(b,f,e);c.B1[h]=y}await af.endReadSection(b),await af.startReadUniqueSection(b,d,7),c.B2=[];for(let i=0;i<c.nVars;i++){let z=await aC(b,f,e);c.B2[i]=z}await af.endReadSection(b),await af.startReadUniqueSection(b,d,8),c.C=[];for(let j=c.nPublic+1;j<c.nVars;j++){let A=await aB(b,f,e);c.C[j]=A}await af.endReadSection(b),await af.startReadUniqueSection(b,d,9),c.hExps=[];for(let o=0;o<c.domainSize;o++){let B=await aB(b,f,e);c.hExps.push(B)}return await af.endReadSection(b),await b.close(),c;async function D(){let a=await af.readBigInt(b,c.n8r);return k.mul(a,C)}}async function aH(a,d,e){let b={delta:{}};b.deltaAfter=await aB(a,d,e),b.delta.g1_s=await aB(a,d,e),b.delta.g1_sx=await aB(a,d,e),b.delta.g2_spx=await aC(a,d,e),b.transcript=await a.read(64),b.type=await a.readULE32();let f=await a.readULE32(),g=a.pos,h=0;for(;a.pos-g<f;){let c=await a.read(1);if(c[0]<=h)throw Error("Parameters in the contribution must be sorted");if(h=c[0],1==c[0]){let i=await a.read(1),j=await a.read(i[0]);b.name=new TextDecoder().decode(j)}else if(2==c[0]){let k=await a.read(1);b.numIterationsExp=k[0]}else if(3==c[0]){let l=await a.read(1);b.beaconHash=await a.read(l[0])}else throw Error("Parameter not recognized")}if(a.pos!=g+f)throw Error("Parametes do not match");return b}async function aI(a,d,e){await af.startReadUniqueSection(a,e,10);let b={contributions:[]};b.csHash=await a.read(64);let f=await a.readULE32();for(let c=0;c<f;c++){let g=await aH(a,d);b.contributions.push(g)}return await af.endReadSection(a),b}async function aJ(c,d,a){await az(c,d,a.deltaAfter),await az(c,d,a.delta.g1_s),await az(c,d,a.delta.g1_sx),await aA(c,d,a.delta.g2_spx),await c.write(a.transcript),await c.writeULE32(a.type||0);let b=[];if(a.name){b.push(1);let e=new TextEncoder("utf-8").encode(a.name.substring(0,64));b.push(e.byteLength);for(let f=0;f<e.byteLength;f++)b.push(e[f])}if(1==a.type){b.push(2),b.push(a.numIterationsExp),b.push(3),b.push(a.beaconHash.byteLength);for(let g=0;g<a.beaconHash.byteLength;g++)b.push(a.beaconHash[g])}if(b.length>0){let h=new Uint8Array(b);await c.writeULE32(h.byteLength),await c.write(h)}else await c.writeULE32(0)}async function aK(a,d,b){await af.startWriteSection(a,10),await a.write(b.csHash),await a.writeULE32(b.contributions.length);for(let c=0;c<b.contributions.length;c++)await aJ(a,d,b.contributions[c]);await af.endWriteSection(a)}function aL(c,a,d){let b=new Uint8Array(2*a.G1.F.n8);a.G1.toRprUncompressed(b,0,d),c.update(b)}function aM(a,c,b){aL(a,c,b.deltaAfter),aL(a,c,b.delta.g1_s),aL(a,c,b.delta.g1_sx),function(c,a,d){let b=new Uint8Array(2*a.G2.F.n8);a.G2.toRprUncompressed(b,0,d),c.update(b)}(a,c,b.delta.g2_spx),a.update(b.transcript)}async function aN(b,c,f){await af.startWriteSection(b,1);let d=(Math.floor((a.Scalar.bitLength(f)-1)/64)+1)*8;await b.writeULE32(d),await af.writeBigInt(b,f,d),await b.writeULE32(c.length),await af.endWriteSection(b),await af.startWriteSection(b,2);for(let e=0;e<c.length;e++)await af.writeBigInt(b,c[e],d);await af.endWriteSection(b,2)}async function aO(b,d,e){await af.startWriteSection(b,1);let c=(Math.floor((a.Scalar.bitLength(e)-1)/64)+1)*8;if(await b.writeULE32(c),await af.writeBigInt(b,e,c),d.byteLength%c!=0)throw Error("Invalid witness length");await b.writeULE32(d.byteLength/c),await af.endWriteSection(b),await af.startWriteSection(b,2),await b.write(d),await af.endWriteSection(b)}async function aP(a,c){await af.startReadUniqueSection(a,c,1);let b=await a.readULE32(),d=await af.readBigInt(a,b),e=await a.readULE32();return await af.endReadSection(a),{n8:b,q:d,nWitness:e}}async function aQ(e){let{fd:a,sections:b}=await af.readBinFile(e,"wtns",2),{n8:f,nWitness:g}=await aP(a,b);await af.startReadUniqueSection(a,b,2);let c=[];for(let d=0;d<g;d++){let h=await af.readBigInt(a,f);c.push(h)}return await af.endReadSection(a),await a.close(),c}let{stringifyBigInts:aR}=a.utils;async function n(v,w,b){let{fd:p,sections:t}=await af.readBinFile(w,"wtns",2,33554432,8388608),q=await aP(p,t),{fd:h,sections:i}=await af.readBinFile(v,"zkey",2,33554432,8388608),e=await aD(h,i);if("groth16"!=e.protocol)throw Error("zkey file is not groth16");if(!a.Scalar.eq(e.r,q.q))throw Error("Curve of the witness does not match the curve of the proving key");if(q.nWitness!=e.nVars)throw Error(`Invalid witness length. Circuit: ${e.nVars}, witness: ${q.nWitness}`);let g=e.curve,d=g.Fr,f=g.G1,k=g.G2,u=ao(e.domainSize);b&&b.debug("Reading Wtns");let j=await af.readSection(p,t,2);b&&b.debug("Reading Coeffs");let x=await af.readSection(h,i,4);b&&b.debug("Building ABC");let[y,z,A]=await aS(g,e,j,x,b),r=u==d.s?g.Fr.shift:g.Fr.w[u+1],B=await d.ifft(y,"","",b,"IFFT_A"),C=await d.batchApplyKey(B,d.e(1),r),D=await d.fft(C,"","",b,"FFT_A"),E=await d.ifft(z,"","",b,"IFFT_B"),F=await d.batchApplyKey(E,d.e(1),r),G=await d.fft(F,"","",b,"FFT_B"),H=await d.ifft(A,"","",b,"IFFT_C"),I=await d.batchApplyKey(H,d.e(1),r),J=await d.fft(I,"","",b,"FFT_C");b&&b.debug("Join ABC");let K=await aT(g,e,D,G,J,b),c={};b&&b.debug("Reading A Points");let L=await af.readSection(h,i,5);c.pi_a=await g.G1.multiExpAffine(L,j,b,"multiexp A"),b&&b.debug("Reading B1 Points");let M=await af.readSection(h,i,6),l=await g.G1.multiExpAffine(M,j,b,"multiexp B1");b&&b.debug("Reading B2 Points");let N=await af.readSection(h,i,7);c.pi_b=await g.G2.multiExpAffine(N,j,b,"multiexp B2"),b&&b.debug("Reading C Points");let O=await af.readSection(h,i,8);c.pi_c=await g.G1.multiExpAffine(O,j.slice((e.nPublic+1)*g.Fr.n8),b,"multiexp C"),b&&b.debug("Reading H Points");let P=await af.readSection(h,i,9),Q=await g.G1.multiExpAffine(P,K,b,"multiexp H"),s=g.Fr.random(),m=g.Fr.random();c.pi_a=f.add(c.pi_a,e.vk_alpha_1),c.pi_a=f.add(c.pi_a,f.timesFr(e.vk_delta_1,s)),c.pi_b=k.add(c.pi_b,e.vk_beta_2),c.pi_b=k.add(c.pi_b,k.timesFr(e.vk_delta_2,m)),l=f.add(l,e.vk_beta_1),l=f.add(l,f.timesFr(e.vk_delta_1,m)),c.pi_c=f.add(c.pi_c,Q),c.pi_c=f.add(c.pi_c,f.timesFr(c.pi_a,m)),c.pi_c=f.add(c.pi_c,f.timesFr(l,s)),c.pi_c=f.add(c.pi_c,f.timesFr(e.vk_delta_1,d.neg(d.mul(s,m))));let n=[];for(let o=1;o<=e.nPublic;o++){let R=j.slice(o*d.n8,o*d.n8+d.n8);n.push(a.Scalar.fromRprLE(R))}return c.pi_a=f.toObject(f.toAffine(c.pi_a)),c.pi_b=k.toObject(k.toAffine(c.pi_b)),c.pi_c=f.toObject(f.toAffine(c.pi_c)),c.protocol="groth16",c.curve=g.name,await h.close(),await p.close(),c=aR(c),n=aR(n),{proof:c,publicSignals:n}}async function aS(f,d,t,m,g){let b=f.Fr.n8,h=12+d.n8r,n=(m.byteLength-4)/h,i=new a.BigBuffer(d.domainSize*b),j=new a.BigBuffer(d.domainSize*b),o=new a.BigBuffer(d.domainSize*b),p=[i,j];for(let e=0;e<n;e++){g&&e%1e6==0&&g.debug(`QAP AB: ${e}/${n}`);let q=m.slice(4+e*h,4+e*h+h),k=new DataView(q.buffer),r=k.getUint32(0,!0),l=k.getUint32(4,!0),s=k.getUint32(8,!0),u=q.slice(12,12+b);p[r].set(f.Fr.add(p[r].slice(l*b,l*b+b),f.Fr.mul(u,t.slice(s*b,s*b+b))),l*b)}for(let c=0;c<d.domainSize;c++)g&&c%1e6==0&&g.debug(`QAP C: ${c}/${d.domainSize}`),o.set(f.Fr.mul(i.slice(c*b,c*b+b),j.slice(c*b,c*b+b)),c*b);return[i,j,o]}async function aT(h,t,f,o,p,l){let c=h.Fr.n8,i=Math.floor(f.byteLength/h.Fr.n8),m=[];for(let b=0;b<i;b+=4194304){l&&l.debug(`JoinABC: ${b}/${i}`);let e=Math.min(i-b,4194304),d=[],q=f.slice(b*c,(b+e)*c),r=o.slice(b*c,(b+e)*c),s=p.slice(b*c,(b+e)*c);d.push({cmd:"ALLOCSET",var:0,buff:q}),d.push({cmd:"ALLOCSET",var:1,buff:r}),d.push({cmd:"ALLOCSET",var:2,buff:s}),d.push({cmd:"ALLOC",var:3,len:e*c}),d.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:e},{var:3},]}),d.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:e},{var:3}]}),d.push({cmd:"GET",out:0,var:3,len:e*c}),m.push(h.tm.queueAction(d))}let j=await Promise.all(m),k;k=f instanceof a.BigBuffer?new a.BigBuffer(f.byteLength):new Uint8Array(f.byteLength);let n=0;for(let g=0;g<j.length;g++)k.set(j[g][0],n),n+=j[g][0].byteLength;return k}let{unstringifyBigInts:aU}=a.utils;async function o(g,h,c,l){let d=aU(g),b=await ai.readExisting(h),i=await b.read(b.totalSize);await b.close();let a=await ad.WitnessCalculatorBuilder(i);if(1==a.circom_version()){let j=await a.calculateBinWitness(d),e=await af.createBinFile(c,"wtns",2,2);await aO(e,j,a.prime),await e.close()}else{let f=await ai.createOverride(c),k=await a.calculateWTNSBin(d);await f.write(k),await f.close()}}let{unstringifyBigInts:aV}=a.utils;async function p(b,c,d,e){let f=aV(b),a={type:"mem"};return await o(f,c,a),await n(d,a,e)}let{unstringifyBigInts:aW}=a.utils;async function q(k,l,m,e){let c=aW(k),g=aW(m),f=aW(l),b=await an(c.curve),n=b.G1.fromObject(c.IC[0]),i=new Uint8Array(2*b.G1.F.n8*f.length),j=new Uint8Array(b.Fr.n8*f.length);for(let d=0;d<f.length;d++){let o=b.G1.fromObject(c.IC[d+1]);i.set(o,d*b.G1.F.n8*2),a.Scalar.toRprLE(j,b.Fr.n8*d,f[d],b.Fr.n8)}let h=await b.G1.multiExpAffine(i,j);h=b.G1.add(h,n);let p=b.G1.fromObject(g.pi_a),q=b.G2.fromObject(g.pi_b),r=b.G1.fromObject(g.pi_c),s=b.G2.fromObject(c.vk_gamma_2),t=b.G2.fromObject(c.vk_delta_2),u=b.G1.fromObject(c.vk_alpha_1),v=b.G2.fromObject(c.vk_beta_2),w=await b.pairingEq(b.G1.neg(p),q,h,s,r,t,u,v);return w?(e&&e.info("OK!"),!0):(e&&e.error("Invalid proof"),!1)}let{unstringifyBigInts:aX}=a.utils;function aY(b){let a=b.toString(16);for(;a.length<64;)a="0"+a;return`"0x${a}"`}async function r(e,f){let a=aX(e),d=aX(f),b="";for(let c=0;c<d.length;c++)""!=b&&(b+=","),b+=aY(d[c]);let g;return`[${aY(a.pi_a[0])}, ${aY(a.pi_a[1])}],[[${aY(a.pi_b[0][1])}, ${aY(a.pi_b[0][0])}],[${aY(a.pi_b[1][1])}, ${aY(a.pi_b[1][0])}]],[${aY(a.pi_c[0])}, ${aY(a.pi_c[1])}],[${b}]`}var s=Object.freeze({__proto__:null,fullProve:p,prove:n,verify:q,exportSolidityCallData:r});function aZ(e,c){let f=new DataView(c.buffer,c.byteOffset,c.byteLength),d=[];for(let b=0;b<8;b++)d[b]=f.getUint32(4*b);let g=new a.ChaCha(d),h=e.G2.fromRng(g);return h}function a$(b,c,d,e,f){let a=ag.default(64),g=new Uint8Array([c]);a.update(g),a.update(d);let h=b.G1.toUncompressed(e);a.update(h);let i=b.G1.toUncompressed(f);a.update(i);let j=a.digest();return aZ(b,j)}function a_(a,b,c,d,e){return a.g1_s=b.G1.toAffine(b.G1.fromRng(e)),a.g1_sx=b.G1.toAffine(b.G1.timesFr(a.g1_s,a.prvKey)),a.g2_sp=b.G2.toAffine(a$(b,c,d,a.g1_s,a.g1_sx)),a.g2_spx=b.G2.toAffine(b.G2.timesFr(a.g2_sp,a.prvKey)),a}function a0(b,d,c){let a={tau:{},alpha:{},beta:{}};return a.tau.prvKey=b.Fr.fromRng(c),a.alpha.prvKey=b.Fr.fromRng(c),a.beta.prvKey=b.Fr.fromRng(c),a_(a.tau,b,0,d,c),a_(a.alpha,b,1,d,c),a_(a.beta,b,2,d,c),a}async function a1(b,c,e,d){d||(d=e),await b.writeULE32(1);let f=b.pos;await b.writeULE64(0),await b.writeULE32(8*c.F1.n64);let g=new Uint8Array(c.F1.n8);a.Scalar.toRprLE(g,0,c.q,c.F1.n8),await b.write(g),await b.writeULE32(e),await b.writeULE32(d);let h=b.pos-f-8,i=b.pos;await b.writeULE64(h,f),b.pos=i}async function a2(b,c){if(!c[1])throw Error(b.fileName+": File has no  header");if(c[1].length>1)throw Error(b.fileName+": File has more than one header");b.pos=c[1][0].p;let d=await b.readULE32(),f=await b.read(d),g=a.Scalar.fromRprLE(f),e=await am(g);if(8*e.F1.n64!=d)throw Error(b.fileName+": Invalid size");let h=await b.readULE32(),i=await b.readULE32();if(b.pos-c[1][0].p!=c[1][0].size)throw Error("Invalid PTau header size");return{curve:e,power:h,ceremonyPower:i}}async function a3(b,a,c){let d=await b.read(12*a.F1.n8+6*a.F2.n8);return a4(d,0,a,c)}function a4(b,c,d,e){let a={tau:{},alpha:{},beta:{}};return a.tau.g1_s=f(),a.tau.g1_sx=f(),a.alpha.g1_s=f(),a.alpha.g1_sx=f(),a.beta.g1_s=f(),a.beta.g1_sx=f(),a.tau.g2_spx=g(),a.alpha.g2_spx=g(),a.beta.g2_spx=g(),a;function f(){let a;return a=e?d.G1.fromRprLEM(b,c):d.G1.fromRprUncompressed(b,c),c+=2*d.G1.F.n8,a}function g(){let a;return a=e?d.G2.fromRprLEM(b,c):d.G2.fromRprUncompressed(b,c),c+=2*d.G2.F.n8,a}}function a5(d,e,f,a,g){async function b(a){g?f.G1.toRprLEM(d,e,a):f.G1.toRprUncompressed(d,e,a),e+=2*f.F1.n8}async function c(a){g?f.G2.toRprLEM(d,e,a):f.G2.toRprUncompressed(d,e,a),e+=2*f.F2.n8}return b(a.tau.g1_s),b(a.tau.g1_sx),b(a.alpha.g1_s),b(a.alpha.g1_sx),b(a.beta.g1_s),b(a.beta.g1_sx),c(a.tau.g2_spx),c(a.alpha.g2_spx),c(a.beta.g2_spx),d}async function a6(c,a,d,e){let b=new Uint8Array(12*a.F1.n8+6*a.F2.n8);a5(b,0,a,d,e),await c.write(b)}async function a7(b,d){let a={};a.tauG1=await n(),a.tauG2=await o(),a.alphaG1=await n(),a.betaG1=await n(),a.betaG2=await o(),a.key=await a3(b,d,!0),a.partialHash=await b.read(216),a.nextChallenge=await b.read(64),a.type=await b.readULE32();let f=new Uint8Array(12*d.G1.F.n8+6*d.G2.F.n8);a5(f,0,d,a.key,!1);let e=ag.default(64);e.setPartialHash(a.partialHash),e.update(f),a.responseHash=e.digest();let g=await b.readULE32(),h=b.pos,i=0;for(;b.pos-h<g;){let c=await p(1);if(c[0]<=i)throw Error("Parameters in the contribution must be sorted");if(i=c[0],1==c[0]){let j=await p(1),k=await p(j[0]);a.name=new TextDecoder().decode(k)}else if(2==c[0]){let l=await p(1);a.numIterationsExp=l[0]}else if(3==c[0]){let m=await p(1);a.beaconHash=await p(m[0])}else throw Error("Parameter not recognized")}if(b.pos!=h+g)throw Error("Parametes do not match");return a;async function n(){let a=await b.read(2*d.G1.F.n8);return d.G1.fromRprLEM(a)}async function o(){let a=await b.read(2*d.G2.F.n8);return d.G2.fromRprLEM(a)}async function p(a){let c=await b.read(a);return new Uint8Array(c)}}async function a8(a,f,b){if(!b[7])throw Error(a.fileName+": File has no  contributions");if(b[7][0].length>1)throw Error(a.fileName+": File has more than one contributions section");a.pos=b[7][0].p;let g=await a.readULE32(),d=[];for(let c=0;c<g;c++){let e=await a7(a,f);e.id=c+1,d.push(e)}if(a.pos-b[7][0].p!=b[7][0].size)throw Error("Invalid contribution section size");return d}async function a9(c,d,a){let i=new Uint8Array(2*d.F1.n8),j=new Uint8Array(2*d.F2.n8);await k(a.tauG1),await l(a.tauG2),await k(a.alphaG1),await k(a.betaG1),await l(a.betaG2),await a6(c,d,a.key,!0),await c.write(a.partialHash),await c.write(a.nextChallenge),await c.writeULE32(a.type||0);let b=[];if(a.name){b.push(1);let e=new TextEncoder("utf-8").encode(a.name.substring(0,64));b.push(e.byteLength);for(let f=0;f<e.byteLength;f++)b.push(e[f])}if(1==a.type){b.push(2),b.push(a.numIterationsExp),b.push(3),b.push(a.beaconHash.byteLength);for(let g=0;g<a.beaconHash.byteLength;g++)b.push(a.beaconHash[g])}if(b.length>0){let h=new Uint8Array(b);await c.writeULE32(h.byteLength),await c.write(h)}else await c.writeULE32(0);async function k(a){d.G1.toRprLEM(i,0,a),await c.write(i)}async function l(a){d.G2.toRprLEM(j,0,a),await c.write(j)}}async function ba(a,e,b){await a.writeULE32(7);let d=a.pos;await a.writeULE64(0),await a.writeULE32(b.length);for(let c=0;c<b.length;c++)await a9(a,e,b[c]);let f=a.pos-d-8,g=a.pos;await a.writeULE64(f,d),a.pos=g}function bb(b,g,a){a&&a.debug("Calculating First Challenge Hash");let e=new ag.default(64),d=new Uint8Array(2*b.G1.F.n8),f=new Uint8Array(2*b.G2.F.n8);b.G1.toRprUncompressed(d,0,b.G1.g),b.G2.toRprUncompressed(f,0,b.G2.g),e.update(ag.default(64).digest());let c;return c=2**g*2-1,a&&a.debug("Calculate Initial Hash: tauG1"),h(d,c),c=2**g,a&&a.debug("Calculate Initial Hash: tauG2"),h(f,c),a&&a.debug("Calculate Initial Hash: alphaTauG1"),h(d,c),a&&a.debug("Calculate Initial Hash: betaTauG1"),h(d,c),e.update(f),e.digest();function h(b,f){let i=Math.floor(f/341e3),j=f%341e3,g=new Uint8Array(341e3*b.byteLength);for(let c=0;c<341e3;c++)g.set(b,c*b.byteLength);for(let d=0;d<i;d++)e.update(g),a&&a.debug("Initial hash: "+341e3*d);for(let h=0;h<j;h++)e.update(b)}}function bc(a,b,c,d){let e=au(c,d),f=a0(a,b,e);return f}async function t(h,c,l,b){await ag.default.ready();let a=await af.createBinFile(l,"ptau",1,7);await a1(a,h,c,0);let i=h.G1.oneAffine,j=h.G2.oneAffine;await af.startWriteSection(a,2);let m=2**c*2-1;for(let d=0;d<m;d++)await a.write(i),b&&d%1e5==0&&d&&b.log("tauG1: "+d);await af.endWriteSection(a),await af.startWriteSection(a,3);let n=2**c;for(let e=0;e<n;e++)await a.write(j),b&&e%1e5==0&&e&&b.log("tauG2: "+e);await af.endWriteSection(a),await af.startWriteSection(a,4);let o=2**c;for(let f=0;f<o;f++)await a.write(i),b&&f%1e5==0&&f&&b.log("alphaTauG1: "+f);await af.endWriteSection(a),await af.startWriteSection(a,5);let p=2**c;for(let g=0;g<p;g++)await a.write(i),b&&g%1e5==0&&g&&b.log("betaTauG1: "+g);await af.endWriteSection(a),await af.startWriteSection(a,6),await a.write(j),await af.endWriteSection(a),await af.startWriteSection(a,7),await a.writeULE32(0),await af.endWriteSection(a),await a.close();let k=bb(h,c,b);return b&&b.debug(ap(ag.default(64).digest(),"Blank Contribution Hash:")),b&&b.info(ap(k,"First Contribution Hash:")),k}async function u(l,m,a){await ag.default.ready();let{fd:f,sections:g}=await af.readBinFile(l,"ptau",1),{curve:h,power:b}=await a2(f,g),c=await a8(f,h,g),d,e;0==c.length?(d=ag.default(64).digest(),e=bb(h,b)):(d=c[c.length-1].responseHash,e=c[c.length-1].nextChallenge),a&&a.info(ap(d,"Last Response Hash: ")),a&&a.info(ap(e,"New Challenge Hash: "));let i=await ai.createOverride(m),j=ag.default(64);await i.write(d),j.update(d),await n(2,"G1",2**b*2-1,"tauG1"),await n(3,"G2",2**b,"tauG2"),await n(4,"G1",2**b,"alphaTauG1"),await n(5,"G1",2**b,"betaTauG1"),await n(6,"G2",1,"betaG2"),await f.close(),await i.close();let k=j.digest();if(!aq(e,k))throw a&&a.info(ap(k,"Calc Curret Challenge Hash: ")),a&&a.error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one"),Error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");return e;async function n(m,n,c,o){let e=h[n],k=2*e.F.n8,l=Math.floor(16777216/k);await af.startReadUniqueSection(f,g,m);for(let b=0;b<c;b+=l){a&&a.debug(`Exporting ${o}: ${b}/${c}`);let p=Math.min(c-b,l),d;await i.write(d=await e.batchLEMtoU(d=await f.read(p*k))),j.update(d)}await af.endReadSection(f)}}async function v(w,x,y,q,r,e){await ag.default.ready();let l=new Uint8Array(64);for(let m=0;m<64;m++)l[m]=255;let{fd:n,sections:s}=await af.readBinFile(w,"ptau",1),{curve:d,power:a}=await a2(n,s),h=await a8(n,d,s),b={};q&&(b.name=q);let z=2*d.F1.n8,o=d.F1.n8,A=2*d.F2.n8,t=d.F2.n8,g=await ai.readExisting(x);if(g.totalSize!=64+(2**a*2-1)*o+2**a*t+2**a*o+2**a*o+t+6*z+3*A)throw Error("Size of the contribution is invalid");let j;j=h.length>0?h[h.length-1].nextChallenge:bb(d,a,e);let c=await af.createBinFile(y,"ptau",1,r?7:2);await a1(c,d,a);let p=await g.read(64);if(aq(l,j)&&(j=p,h[h.length-1].nextChallenge=j),!aq(p,j))throw Error("Wrong contribution. this contribution is not based on the previus hash");let k=new ag.default(64);k.update(p);let B=[],f;f=await C(g,c,"G1",2,2**a*2-1,[1],"tauG1"),b.tauG1=f[0],f=await C(g,c,"G2",3,2**a,[1],"tauG2"),b.tauG2=f[0],f=await C(g,c,"G1",4,2**a,[0],"alphaG1"),b.alphaG1=f[0],f=await C(g,c,"G1",5,2**a,[0],"betaG1"),b.betaG1=f[0],f=await C(g,c,"G2",6,1,[0],"betaG2"),b.betaG2=f[0],b.partialHash=k.getPartialHash();let u=await g.read(12*d.F1.n8+6*d.F2.n8);b.key=a4(u,0,d,!1),k.update(new Uint8Array(u));let v=k.digest();if(e&&e.info(ap(v,"Contribution Response Hash imported: ")),r){let i=new ag.default(64);i.update(v),await F(i,c,"G1",2,2**a*2-1,"tauG1",e),await F(i,c,"G2",3,2**a,"tauG2",e),await F(i,c,"G1",4,2**a,"alphaTauG1",e),await F(i,c,"G1",5,2**a,"betaTauG1",e),await F(i,c,"G2",6,1,"betaG2",e),b.nextChallenge=i.digest(),e&&e.info(ap(b.nextChallenge,"Next Challenge Hash: "))}else b.nextChallenge=l;return h.push(b),await ba(c,d,h),await g.close(),await c.close(),await n.close(),b.nextChallenge;async function C(a,b,c,d,e,f,g){return r?await D(a,b,c,d,e,f,g):await E(a,b,c,d,e,f,g)}async function D(r,b,s,i,f,j,t){let c=d[s],u=c.F.n8,l=2*c.F.n8,m=[];await af.startWriteSection(b,i);let n=Math.floor(16777216/l);B[i]=b.pos;for(let a=0;a<f;a+=n){e&&e.debug(`Importing ${t}: ${a}/${f}`);let o=Math.min(f-a,n),p=await r.read(o*u);k.update(p);let q=await c.batchCtoLEM(p);await b.write(q);for(let g=0;g<j.length;g++){let h=j[g];if(h>=a&&h<a+o){let v=c.fromRprLEM(q,(h-a)*l);m.push(v)}}}return await af.endWriteSection(b),m}async function E(o,s,p,t,b,h,q){let i=d[p],c=i.F.n8,j=[],l=Math.floor(16777216/c);for(let a=0;a<b;a+=l){e&&e.debug(`Importing ${q}: ${a}/${b}`);let m=Math.min(b-a,l),n=await o.read(m*c);k.update(n);for(let f=0;f<h.length;f++){let g=h[f];if(g>=a&&g<a+m){let r=i.fromRprCompressed(n,(g-a)*c);j.push(r)}}}return j}async function F(i,a,j,k,c,l,e){let f=d[j],g=2*f.F.n8,h=Math.floor(16777216/g),m=a.pos;a.pos=B[k];for(let b=0;b<c;b+=h){e&&e.debug(`Hashing ${l}: ${b}/${c}`);let n=Math.min(c-b,h),o=await a.read(n*g),p=await f.batchLEMtoU(o);i.update(p)}a.pos=m}}let bd=g;async function be(c,a,d,b){let f;if(1==a.type){let e=bc(c,d.nextChallenge,a.beaconHash,a.numIterationsExp);if(!c.G1.eq(a.key.tau.g1_s,e.tau.g1_s))return b&&b.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!c.G1.eq(a.key.tau.g1_sx,e.tau.g1_sx))return b&&b.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!c.G2.eq(a.key.tau.g2_spx,e.tau.g2_spx))return b&&b.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!c.G1.eq(a.key.alpha.g1_s,e.alpha.g1_s))return b&&b.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!c.G1.eq(a.key.alpha.g1_sx,e.alpha.g1_sx))return b&&b.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!c.G2.eq(a.key.alpha.g2_spx,e.alpha.g2_spx))return b&&b.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!c.G1.eq(a.key.beta.g1_s,e.beta.g1_s))return b&&b.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!c.G1.eq(a.key.beta.g1_sx,e.beta.g1_sx))return b&&b.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!c.G2.eq(a.key.beta.g2_spx,e.beta.g2_spx))return b&&b.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1}return(a.key.tau.g2_sp=c.G2.toAffine(a$(c,0,d.nextChallenge,a.key.tau.g1_s,a.key.tau.g1_sx)),a.key.alpha.g2_sp=c.G2.toAffine(a$(c,1,d.nextChallenge,a.key.alpha.g1_s,a.key.alpha.g1_sx)),a.key.beta.g2_sp=c.G2.toAffine(a$(c,2,d.nextChallenge,a.key.beta.g1_s,a.key.beta.g1_sx)),!0!==await bd(c,a.key.tau.g1_s,a.key.tau.g1_sx,a.key.tau.g2_sp,a.key.tau.g2_spx))?(b&&b.error("INVALID key (tau) in challenge #"+a.id),!1):!0!==await bd(c,a.key.alpha.g1_s,a.key.alpha.g1_sx,a.key.alpha.g2_sp,a.key.alpha.g2_spx)?(b&&b.error("INVALID key (alpha) in challenge #"+a.id),!1):!0!==await bd(c,a.key.beta.g1_s,a.key.beta.g1_sx,a.key.beta.g2_sp,a.key.beta.g2_spx)?(b&&b.error("INVALID key (beta) in challenge #"+a.id),!1):!0!==await bd(c,d.tauG1,a.tauG1,a.key.tau.g2_sp,a.key.tau.g2_spx)?(b&&b.error("INVALID tau*G1. challenge #"+a.id+" It does not follow the previous contribution"),!1):!0!==await bd(c,a.key.tau.g1_s,a.key.tau.g1_sx,d.tauG2,a.tauG2)?(b&&b.error("INVALID tau*G2. challenge #"+a.id+" It does not follow the previous contribution"),!1):!0!==await bd(c,d.alphaG1,a.alphaG1,a.key.alpha.g2_sp,a.key.alpha.g2_spx)?(b&&b.error("INVALID alpha*G1. challenge #"+a.id+" It does not follow the previous contribution"),!1):!0!==await bd(c,d.betaG1,a.betaG1,a.key.beta.g2_sp,a.key.beta.g2_spx)?(b&&b.error("INVALID beta*G1. challenge #"+a.id+" It does not follow the previous contribution"),!1):!0!==await bd(c,a.key.beta.g1_s,a.key.beta.g1_sx,d.betaG2,a.betaG2)?(b&&b.error("INVALID beta*G2. challenge #"+a.id+"It does not follow the previous contribution"),!1):(b&&b.info("Powers Of tau file OK!"),!0)}async function w(u,b){let y;await ag.default.ready();let{fd:k,sections:f}=await af.readBinFile(u,"ptau",1),{curve:c,power:g,ceremonyPower:o}=await a2(k,f),e=await a8(k,c,f);b&&b.debug("power: 2**"+g),b&&b.debug("Computing initial contribution hash");let p={tauG1:c.G1.g,tauG2:c.G2.g,alphaG1:c.G1.g,betaG1:c.G1.g,betaG2:c.G2.g,nextChallenge:bb(c,o,b),responseHash:ag.default(64).digest()};if(0==e.length)return b&&b.error("This file has no contribution! It cannot be used in production"),!1;let l;l=e.length>1?e[e.length-2]:p;let d=e[e.length-1];b&&b.debug("Validating contribution #"+e[e.length-1].id);let v=await be(c,d,l,b);if(!v)return!1;let q=ag.default(64);q.update(d.responseHash),b&&b.debug("Verifying powers in tau*G1 section");let i=await C(2,"G1","tauG1",2**g*2-1,[0,1],b);if(!0!==await bd(c,i.R1,i.R2,c.G2.g,d.tauG2))return b&&b.error("tauG1 section. Powers do not match"),!1;if(!c.G1.eq(c.G1.g,i.singularPoints[0]))return b&&b.error("First element of tau*G1 section must be the generator"),!1;if(!c.G1.eq(d.tauG1,i.singularPoints[1]))return b&&b.error("Second element of tau*G1 section does not match the one in the contribution section"),!1;b&&b.debug("Verifying powers in tau*G2 section");let j=await C(3,"G2","tauG2",2**g,[0,1],b);if(!0!==await bd(c,c.G1.g,d.tauG1,j.R1,j.R2))return b&&b.error("tauG2 section. Powers do not match"),!1;if(!c.G2.eq(c.G2.g,j.singularPoints[0]))return b&&b.error("First element of tau*G2 section must be the generator"),!1;if(!c.G2.eq(d.tauG2,j.singularPoints[1]))return b&&b.error("Second element of tau*G2 section does not match the one in the contribution section"),!1;b&&b.debug("Verifying powers in alpha*tau*G1 section");let m=await C(4,"G1","alphatauG1",2**g,[0],b);if(!0!==await bd(c,m.R1,m.R2,c.G2.g,d.tauG2))return b&&b.error("alphaTauG1 section. Powers do not match"),!1;if(!c.G1.eq(d.alphaG1,m.singularPoints[0]))return b&&b.error("First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section"),!1;b&&b.debug("Verifying powers in beta*tau*G1 section");let n=await C(5,"G1","betatauG1",2**g,[0],b);if(!0!==await bd(c,n.R1,n.R2,c.G2.g,d.tauG2))return b&&b.error("betaTauG1 section. Powers do not match"),!1;if(!c.G1.eq(d.betaG1,n.singularPoints[0]))return b&&b.error("First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section"),!1;let w=await B(b);if(!c.G2.eq(d.betaG2,w))return b&&b.error("betaG2 element in betaG2 section does not match the one in the contribution section"),!1;let r=q.digest();if(g==o&&!aq(r,d.nextChallenge))return b&&b.error("Hash of the values does not match the next challenge of the last contributor in the contributions section"),!1;b&&b.info(ap(r,"Next challenge hash: ")),A(d,l);for(let h=e.length-2;h>=0;h--){let s=e[h],t=h>0?e[h-1]:p,x=await be(c,s,t,b);if(!x)return!1;A(s,t)}if(b&&b.info("-----------------------------------------------------"),f[12]&&f[13]&&f[14]&&f[15]){let z;if(!await D("G1",2,12,"tauG1",b)||!await D("G2",3,13,"tauG2",b)||!await D("G1",4,14,"alphaTauG1",b)||!await D("G1",5,15,"betaTauG1",b))return!1}else b&&b.warn('this file does not contain phase2 precalculated values. Please run: \n   snarkjs "powersoftau preparephase2" to prepare this file to be used in the phase2 ceremony.');return await k.close(),b&&b.info("Powers of Tau Ok!"),!0;function A(a,f){if(!b)return;b.info("-----------------------------------------------------"),b.info(`Contribution #${a.id}: ${a.name||""}`),b.info(ap(a.nextChallenge,"Next Challenge: "));let e=new Uint8Array(12*c.G1.F.n8+6*c.G2.F.n8);a5(e,0,c,a.key,!1);let d=ag.default(64);d.setPartialHash(a.partialHash),d.update(e);let g=d.digest();b.info(ap(g,"Response Hash:")),b.info(ap(f.nextChallenge,"Response Hash:")),1==a.type&&(b.info(`Beacon generator: ${aw(a.beaconHash)}`),b.info(`Beacon iterations Exp: ${a.numIterationsExp}`))}async function B(b){let a=c.G2,d=2*a.F.n8,e=new Uint8Array(d);if(!f[6])throw b.error("File has no BetaG2 section"),Error("File has no BetaG2 section");if(f[6].length>1)throw b.error("File has no BetaG2 section"),Error("File has more than one GetaG2 section");k.pos=f[6][0].p;let h=await k.read(d),g=a.fromRprLEM(h);return a.toRprUncompressed(e,0,g),q.update(e),g}async function C(v,w,x,j,o,p){let r=65536,a=c[w],e=2*a.F.n8;await af.startReadUniqueSection(k,f,v);let s=[],g=a.zero,h=a.zero,t=a.zero;for(let b=0;b<j;b+=r){p&&p.debug(`points relations: ${x}: ${b}/${j} `);let i=Math.min(j-b,r),d=await k.read(i*e),y=await a.batchLEMtoU(d);q.update(y);let l=new Uint8Array(4*(i-1));if(ah.default.randomFillSync(l),b>0){let z=a.fromRprLEM(d,0),u=ah.default.randomBytes(4).readUInt32BE(0,!0);g=a.add(g,a.timesScalar(t,u)),h=a.add(h,a.timesScalar(z,u))}let A=await a.multiExpAffine(d.slice(0,(i-1)*e),l),B=await a.multiExpAffine(d.slice(e),l);g=a.add(g,A),h=a.add(h,B),t=a.fromRprLEM(d,(i-1)*e);for(let m=0;m<o.length;m++){let n=o[m];if(n>=b&&n<b+i){let C=a.fromRprLEM(d,(n-b)*e);s.push(C)}}}return await af.endReadSection(k),{R1:g,R2:h,singularPoints:s}}async function D(h,i,p,j,e){e&&e.debug(`Verifying phase2 calculated values ${j}...`);let l=c[h],q=2*l.F.n8,m=Array(8);for(let b=0;b<8;b++)m[b]=ah.default.randomBytes(4).readUInt32BE(0,!0);for(let d=0;d<=g;d++){let n=await r(d);if(!n)return!1}if(2==i){let o=await r(g+1);if(!o)return!1}return!0;async function r(d){e&&e.debug(`Power ${d}...`);let t=c.Fr.n8,h=2**d,b=new Uint32Array(h),n,s=new a.ChaCha(m);e&&e.debug(`Creating random numbers Powers${d}...`);for(let o=0;o<h;o++)d==g+1&&o==h-1?b[o]=0:b[o]=s.nextU32();b=new Uint8Array(b.buffer,b.byteOffset,b.byteLength),e&&e.debug(`reading points Powers${d}...`),await af.startReadUniqueSection(k,f,i),n=new a.BigBuffer(h*q),d==g+1?(await k.readToBuffer(n,0,(h-1)*q),n.set(c.G1.zeroAffine,(h-1)*q)):await k.readToBuffer(n,0,h*q),await af.endReadSection(k,!0);let v=await l.multiExpAffine(n,b,e,j+"_"+d);b=new a.BigBuffer(h*t),s=new a.ChaCha(m);let u=new Uint8Array(4),w=new DataView(u.buffer);e&&e.debug(`Creating random numbers Powers${d}...`);for(let r=0;r<h;r++)(r!=h-1||d!=g+1)&&(w.setUint32(0,s.nextU32(),!0),b.set(u,r*t));e&&e.debug(`batchToMontgomery ${d}...`),b=await c.Fr.batchToMontgomery(b),e&&e.debug(`fft ${d}...`),b=await c.Fr.fft(b),e&&e.debug(`batchFromMontgomery ${d}...`),b=await c.Fr.batchFromMontgomery(b),e&&e.debug(`reading points Lagrange${d}...`),await af.startReadUniqueSection(k,f,p),k.pos+=q*(2**d-1),await k.readToBuffer(n,0,h*q),await af.endReadSection(k,!0);let x=await l.multiExpAffine(n,b,e,j+"_"+d+"_transformed");return!!l.eq(v,x)||(e&&e.error("Phase2 caclutation does not match with powers of tau"),!1)}}}async function bf(b,h,c,d,e,n,o,i,p,j){let k=e[n],l=2*k.F.n8,f=h[d][0].size/l;await af.startReadUniqueSection(b,h,d),await af.startWriteSection(c,d);let g=o;for(let a=0;a<f;a+=65536){j&&j.debug(`Applying key: ${p}: ${a}/${f}`);let m=Math.min(f-a,65536),q;await c.write(await k.batchApplyKey(await b.read(m*l),g,i)),g=e.Fr.mul(g,e.Fr.exp(i,m))}await af.endWriteSection(c),await af.endReadSection(b)}async function bg(n,o,g,c,p,d,q,h,r,s,i){let a=c[p],j=2*a.F.n8,k=Math.floor(1048576/j),e=q;for(let b=0;b<d;b+=k){i&&i.debug(`Applying key ${s}: ${b}/${d}`);let l=Math.min(d-b,k),t=await n.read(l*j),u=await a.batchUtoLEM(t),m=await a.batchApplyKey(u,e,h),f;f="COMPRESSED"==r?await a.batchLEMtoC(m):await a.batchLEMtoU(m),g&&g.update(f),await o.write(f),e=c.Fr.mul(e,c.Fr.exp(h,l))}}async function x(c,p,q,r,a){await ag.default.ready();let b=await ai.readExisting(p),k=16*c.F1.n64,l=16*c.F2.n64,m=(b.totalSize+k-64-l)/(4*k+l),n=m,g=0;for(;n>1;)n/=2,g+=1;if(2**g!=m)throw Error("Invalid file size");a&&a.debug("Power to tau size: "+g);let s=await at(r),e=await ai.createOverride(q),o=ag.default(64);for(let h=0;h<b.totalSize;h+=b.pageSize){a&&a.debug(`Hashing challenge ${h}/${b.totalSize}`);let t=Math.min(b.totalSize-h,b.pageSize),u=await b.read(t);o.update(u)}let v=await b.read(64,0);a&&a.info(ap(v,"Claimed Previous Response Hash: "));let i=o.digest();a&&a.info(ap(i,"Current Challenge Hash: "));let d=a0(c,i,s);a&&["tau","alpha","beta"].forEach(b=>{a.debug(b+".g1_s: "+c.G1.toString(d[b].g1_s,16)),a.debug(b+".g1_sx: "+c.G1.toString(d[b].g1_sx,16)),a.debug(b+".g2_sp: "+c.G2.toString(d[b].g2_sp,16)),a.debug(b+".g2_spx: "+c.G2.toString(d[b].g2_spx,16)),a.debug("")});let f=ag.default(64);await e.write(i),f.update(i),await bg(b,e,f,c,"G1",2**g*2-1,c.Fr.one,d.tau.prvKey,"COMPRESSED","tauG1",a),await bg(b,e,f,c,"G2",2**g,c.Fr.one,d.tau.prvKey,"COMPRESSED","tauG2",a),await bg(b,e,f,c,"G1",2**g,d.alpha.prvKey,d.tau.prvKey,"COMPRESSED","alphaTauG1",a),await bg(b,e,f,c,"G1",2**g,d.beta.prvKey,d.tau.prvKey,"COMPRESSED","betaTauG1",a),await bg(b,e,f,c,"G2",1,d.beta.prvKey,d.tau.prvKey,"COMPRESSED","betaTauG2",a);let j=new Uint8Array(12*c.F1.n8+6*c.F2.n8);a5(j,0,c,d,!1),await e.write(j),f.update(j);let w=f.digest();a&&a.info(ap(w,"Contribution Response Hash: ")),await e.close(),await b.close()}async function y(r,s,t,o,g,a){let h=av(o);if(0==h.byteLength||2*h.byteLength!=o.length)return a&&a.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(h.length>=256)return a&&a.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((g=parseInt(g))<10||g>63)return a&&a.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;await ag.default.ready();let{fd:k,sections:l}=await af.readBinFile(r,"ptau",1),{curve:d,power:c,ceremonyPower:u}=await a2(k,l);if(c!=u)return a&&a.error("This file has been reduced. You cannot contribute into a reduced file."),!1;l[12]&&a&&a.warn("Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");let i=await a8(k,d,l),b={name:t,type:1,numIterationsExp:g,beaconHash:h},m;m=i.length>0?i[i.length-1].nextChallenge:bb(d,c,a),b.key=bc(d,m,h,g);let j=new ag.default(64);j.update(m);let f=await af.createBinFile(s,"ptau",1,7);await a1(f,d,c);let v=[],e;e=await w(2,"G1",2**c*2-1,d.Fr.e(1),b.key.tau.prvKey,"tauG1",a),b.tauG1=e[1],e=await w(3,"G2",2**c,d.Fr.e(1),b.key.tau.prvKey,"tauG2",a),b.tauG2=e[1],e=await w(4,"G1",2**c,b.key.alpha.prvKey,b.key.tau.prvKey,"alphaTauG1",a),b.alphaG1=e[0],e=await w(5,"G1",2**c,b.key.beta.prvKey,b.key.tau.prvKey,"betaTauG1",a),b.betaG1=e[0],e=await w(6,"G2",1,b.key.beta.prvKey,b.key.tau.prvKey,"betaTauG2",a),b.betaG2=e[0],b.partialHash=j.getPartialHash();let p=new Uint8Array(12*d.F1.n8+6*d.F2.n8);a5(p,0,d,b.key,!1),j.update(new Uint8Array(p));let n=j.digest();a&&a.info(ap(n,"Contribution Response Hash imported: "));let q=new ag.default(64);return q.update(n),await x(f,"G1",2,2**c*2-1,"tauG1",a),await x(f,"G2",3,2**c,"tauG2",a),await x(f,"G1",4,2**c,"alphaTauG1",a),await x(f,"G1",5,2**c,"betaTauG1",a),await x(f,"G2",6,1,"betaG2",a),b.nextChallenge=q.digest(),a&&a.info(ap(b.nextChallenge,"Next Challenge Hash: ")),i.push(b),await ba(f,d,i),await k.close(),await f.close(),n;async function w(e,s,b,t,n,u,o){let p=[];k.pos=l[e][0].p,await af.startWriteSection(f,e),v[e]=f.pos;let c=d[s],g=2*c.F.n8,q=Math.floor(1048576/g),h=t;for(let a=0;a<b;a+=q){o&&o.debug(`applying key${u}: ${a}/${b}`);let r=Math.min(b-a,q),w=await k.read(r*g),i=await c.batchApplyKey(w,h,n),x=f.write(i),y=await c.batchLEMtoC(i);if(j.update(y),await x,0==a)for(let m=0;m<Math.min(2,b);m++)p.push(c.fromRprLEM(i,m*g));h=d.Fr.mul(h,d.Fr.exp(n,r))}return await af.endWriteSection(f),p}async function x(a,i,j,c,k,e){let f=d[i],g=2*f.F.n8,h=Math.floor(16777216/g),l=a.pos;a.pos=v[j];for(let b=0;b<c;b+=h){e&&e.debug(`Hashing ${k}: ${b}/${c}`);let m=Math.min(c-b,h),n=await a.read(m*g),o=await f.batchLEMtoU(n);q.update(o)}a.pos=l}}async function z(o,p,q,r,e){await ag.default.ready();let{fd:i,sections:j}=await af.readBinFile(o,"ptau",1),{curve:c,power:b,ceremonyPower:s}=await a2(i,j);if(b!=s)throw e&&e.error("This file has been reduced. You cannot contribute into a reduced file."),Error("This file has been reduced. You cannot contribute into a reduced file.");j[12]&&e&&e.warn("WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");let g=await a8(i,c,j),a={name:q,type:0},k,t=await at(r);k=g.length>0?g[g.length-1].nextChallenge:bb(c,b,e),a.key=a0(c,k,t);let h=new ag.default(64);h.update(k);let f=await af.createBinFile(p,"ptau",1,7);await a1(f,c,b);let u=[],d;d=await v(2,"G1",2**b*2-1,c.Fr.e(1),a.key.tau.prvKey,"tauG1"),a.tauG1=d[1],d=await v(3,"G2",2**b,c.Fr.e(1),a.key.tau.prvKey,"tauG2"),a.tauG2=d[1],d=await v(4,"G1",2**b,a.key.alpha.prvKey,a.key.tau.prvKey,"alphaTauG1"),a.alphaG1=d[0],d=await v(5,"G1",2**b,a.key.beta.prvKey,a.key.tau.prvKey,"betaTauG1"),a.betaG1=d[0],d=await v(6,"G2",1,a.key.beta.prvKey,a.key.tau.prvKey,"betaTauG2"),a.betaG2=d[0],a.partialHash=h.getPartialHash();let m=new Uint8Array(12*c.F1.n8+6*c.F2.n8);a5(m,0,c,a.key,!1),h.update(new Uint8Array(m));let l=h.digest();e&&e.info(ap(l,"Contribution Response Hash imported: "));let n=new ag.default(64);return n.update(l),await w(f,"G1",2,2**b*2-1,"tauG1"),await w(f,"G2",3,2**b,"tauG2"),await w(f,"G1",4,2**b,"alphaTauG1"),await w(f,"G1",5,2**b,"betaTauG1"),await w(f,"G2",6,1,"betaG2"),a.nextChallenge=n.digest(),e&&e.info(ap(a.nextChallenge,"Next Challenge Hash: ")),g.push(a),await ba(f,c,g),await i.close(),await f.close(),l;async function v(g,s,b,t,o,v){let p=[];i.pos=j[g][0].p,await af.startWriteSection(f,g),u[g]=f.pos;let d=c[s],k=2*d.F.n8,q=Math.floor(1048576/k),l=t;for(let a=0;a<b;a+=q){e&&e.debug(`processing: ${v}: ${a}/${b}`);let r=Math.min(b-a,q),w=await i.read(r*k),m=await d.batchApplyKey(w,l,o),x=f.write(m),y=await d.batchLEMtoC(m);if(h.update(y),await x,0==a)for(let n=0;n<Math.min(2,b);n++)p.push(d.fromRprLEM(m,n*k));l=c.Fr.mul(l,c.Fr.exp(o,r))}return await af.endWriteSection(f),p}async function w(b,i,j,d,k){let f=c[i],g=2*f.F.n8,h=Math.floor(16777216/g),l=b.pos;b.pos=u[j];for(let a=0;a<d;a+=h){e&&a&&e.debug(`Hashing ${k}: `+a);let m=Math.min(d-a,h),o=await b.read(m*g),p=await f.batchLEMtoU(o);n.update(p)}b.pos=l}}async function A(f,g,j){let{fd:b,sections:d}=await af.readBinFile(f,"ptau",1),{curve:h,power:i}=await a2(b,d),c=await af.createBinFile(g,"ptau",1,11);async function e(f,g,m,k){j&&j.debug("Starting section: "+k),await af.startWriteSection(c,g);for(let e=0;e<=i;e++)await l(e);async function l(o){let g=2**o,n=h[m];h.Fr;let l=2*n.F.n8;n.F.n8;let e;e=new a.BigBuffer(g*l),await af.startReadUniqueSection(b,d,f),2==f&&o==i+1?(await b.readToBuffer(e,0,(g-1)*l),e.set(h.G1.zeroAffine,(g-1)*l)):await b.readToBuffer(e,0,g*l),await af.endReadSection(b,!0),await c.write(e=await n.lagrangeEvaluations(e,"affine","affine",j,k))}2==f&&await l(i+1),await af.endWriteSection(c)}await a1(c,h,i),await af.copySection(b,d,c,2),await af.copySection(b,d,c,3),await af.copySection(b,d,c,4),await af.copySection(b,d,c,5),await af.copySection(b,d,c,6),await af.copySection(b,d,c,7),await e(2,12,"G1","tauG1"),await e(3,13,"G2","tauG2"),await e(4,14,"G1","alphaTauG1"),await e(5,15,"G1","betaTauG1"),await b.close(),await c.close()}async function B(d,g,h){let{fd:b,sections:e}=await af.readBinFile(d,"ptau",1),{curve:c,power:f,ceremonyPower:i}=await a2(b,e),j=2*c.G1.F.n8,k=2*c.G2.F.n8;for(let a=1;a<f;a++)await l(a);return await b.close(),!0;async function l(d){let f=d.toString();for(;f.length<2;)f="0"+f;h&&h.debug("Writing Power: "+f);let a=await af.createBinFile(g+f+".ptau","ptau",1,11);await a1(a,c,d,i),await af.copySection(b,e,a,2,(2**d*2-1)*j),await af.copySection(b,e,a,3,2**d*k),await af.copySection(b,e,a,4,2**d*j),await af.copySection(b,e,a,5,2**d*j),await af.copySection(b,e,a,6,k),await af.copySection(b,e,a,7),await af.copySection(b,e,a,12,(2**(d+1)*2-1)*j),await af.copySection(b,e,a,13,(2**d*2-1)*k),await af.copySection(b,e,a,14,(2**d*2-1)*j),await af.copySection(b,e,a,15,(2**d*2-1)*j),await a.close()}}async function C(e,f,j){let{fd:b,sections:d}=await af.readBinFile(e,"ptau",1),{curve:g,power:h}=await a2(b,d),c=await af.createBinFile(f,"ptau",1,11);async function i(l,e,q,m){j&&j.debug("Starting section: "+m),await af.startWriteSection(c,e);let i=d[e][0].size,k=b.pageSize;await af.startReadUniqueSection(b,d,e);for(let f=0;f<i;f+=k){let n=Math.min(i-f,k),o=await b.read(n);await c.write(o)}async function p(k){let f=2**k,n=g[q],i=2*n.F.n8,e;e=new a.BigBuffer(f*i),await af.startReadUniqueSection(b,d,l),2==l&&k==h+1?(await b.readToBuffer(e,0,(f-1)*i),e.set(g.G1.zeroAffine,(f-1)*i)):await b.readToBuffer(e,0,f*i),await af.endReadSection(b,!0),await c.write(e=await n.lagrangeEvaluations(e,"affine","affine",j,m))}await af.endReadSection(b),2==l&&await p(h+1),await af.endWriteSection(c)}await a1(c,g,h),await af.copySection(b,d,c,2),await af.copySection(b,d,c,3),await af.copySection(b,d,c,4),await af.copySection(b,d,c,5),await af.copySection(b,d,c,6),await af.copySection(b,d,c,7),await i(2,12,"G1","tauG1"),await af.copySection(b,d,c,13),await af.copySection(b,d,c,14),await af.copySection(b,d,c,15),await b.close(),await c.close()}async function D(f,g){let{fd:c,sections:e}=await af.readBinFile(f,"ptau",1),{curve:d,power:b}=await a2(c,e),a={};return a.q=d.q,a.power=b,a.contributions=await a8(c,d,e),a.tauG1=await h(2,"G1",2**b*2-1,"tauG1"),a.tauG2=await h(3,"G2",2**b,"tauG2"),a.alphaTauG1=await h(4,"G1",2**b,"alphaTauG1"),a.betaTauG1=await h(5,"G1",2**b,"betaTauG1"),a.betaG2=await h(6,"G2",1,"betaG2"),a.lTauG1=await i(12,"G1","lTauG1"),a.lTauG2=await i(13,"G2","lTauG2"),a.lAlphaTauG1=await i(14,"G1","lAlphaTauG2"),a.lBetaTauG1=await i(15,"G1","lBetaTauG2"),await c.close(),ax(d.Fr,a);async function h(h,i,j,k){let b=d[i],l=2*b.F.n8,f=[];await af.startReadUniqueSection(c,e,h);for(let a=0;a<j;a++){g&&a&&a%1e4==0&&console.log(`${k}: `+a);let m=await c.read(l);f.push(b.fromRprLEM(m,0))}return await af.endReadSection(c),f}async function i(l,m,i){let j=d[m],n=2*j.F.n8,h=[];await af.startReadUniqueSection(c,e,l);for(let a=0;a<=b;a++){g&&console.log(`${i}: Power: ${a}`),h[a]=[];let k=2**a;for(let f=0;f<k;f++){g&&f&&f%1e4==0&&console.log(`${i}: ${f}/${k}`);let o=await c.read(n);h[a].push(j.fromRprLEM(o,0))}}return await af.endReadSection(c,!0),h}}var E=Object.freeze({__proto__:null,newAccumulator:t,exportChallenge:u,importResponse:v,verify:w,challengeContribute:x,beacon:y,contribute:z,preparePhase2:A,truncate:B,convert:C,exportJson:D});let bh=a.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),bi=a.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");async function F(d,b){let c=await ae.readR1cs(d);return a.Scalar.eq(c.prime,bi)?b&&b.info("Curve: bn-128"):a.Scalar.eq(c.prime,bh)?b&&b.info("Curve: bls12-381"):b&&b.info(`Unknown Curve. Prime: ${a.Scalar.toString(c.prime)}`),b&&b.info(`# of Wires: ${c.nVars}`),b&&b.info(`# of Constraints: ${c.nConstraints}`),b&&b.info(`# of Private Inputs: ${c.nPrvInputs}`),b&&b.info(`# of Public Inputs: ${c.nPubInputs}`),b&&b.info(`# of Labels: ${c.nLabels}`),b&&b.info(`# of Outputs: ${c.nOutputs}`),c}async function G(b,c){let a=await ae.readR1cs(b,!0,!0,!0,c),d=a.curve.Fr;return delete a.curve,delete a.F,ax(d,a)}var H=Object.freeze({__proto__:null,print:function(b,c,d){for(let a=0;a<b.constraints.length;a++)e(b.constraints[a]);function e(a){let e=a=>{let d="",e=Object.keys(a);return e.forEach(g=>{let f=c.varIdx2Name[g];"one"==f&&(f="");let e=b.curve.Fr.toString(a[g]);"1"==e&&(e=""),"-1"==e&&(e="-"),""!=d&&"-"!=e[0]&&(e="+"+e),""!=d&&(e=" "+e),d=d+e+f}),d},f=`[ ${e(a[0])} ] * [ ${e(a[1])} ] - [ ${e(a[2])} ] = 0`;d&&d.info(f)}},info:F,exportJson:G});async function bj(f){let b={labelIdx2Name:["one"],varIdx2Name:["one"],componentIdx2Name:[]},c=await ai.readExisting(f),g=await c.read(c.totalSize),h=new TextDecoder("utf-8").decode(g),e=h.split("\n");for(let d=0;d<e.length;d++){let a=e[d].split(",");4!=a.length||(b.varIdx2Name[a[1]]?b.varIdx2Name[a[1]]+="|"+a[3]:b.varIdx2Name[a[1]]=a[3],b.labelIdx2Name[a[0]]=a[3],b.componentIdx2Name[a[2]]||(b.componentIdx2Name[a[2]]=i(a[3])))}return await c.close(),b;function i(b){let a=b.split(".");return a.pop(),a.join(".")}}let{unstringifyBigInts:bk}=a.utils;async function I(h,i,j,c,d,n){let k=bk(h),e=await ai.readExisting(i),l=await e.read(e.totalSize);await e.close();let b={sanityCheck:!0},a=await bj(c);d.set&&(a||(a=await bj(c)),b.logSetSignal=function(b,c){n&&n.info("SET "+a.labelIdx2Name[b]+" <-- "+c.toString())}),d.get&&(a||(a=await bj(c)),b.logGetSignal=function(b,c){n&&n.info("GET "+a.labelIdx2Name[b]+" --> "+c.toString())}),d.trigger&&(a||(a=await bj(c)),b.logStartComponent=function(b){n&&n.info("START: "+a.componentIdx2Name[b])},b.logFinishComponent=function(b){n&&n.info("FINISH: "+a.componentIdx2Name[b])}),b.sym=a;let f=await ad.WitnessCalculatorBuilder(l,b),m=await f.calculateWitness(k),g=await af.createBinFile(j,"wtns",2,2);await aN(g,m,f.prime),await g.close()}async function J(a){let b=await aQ(a);return b}var K=Object.freeze({__proto__:null,calculate:o,debug:I,exportJson:J});class bl{constructor(a){let b=new class{constructor(b){this.length=b||0,this.arr=Array(262144);for(let a=0;a<b;a+=262144)this.arr[a/262144]=Array(Math.min(262144,b-a));return this}push(){for(let a=0;a<arguments.length;a++)this.setElement(this.length,arguments[a])}slice(b,c){let d=Array(c-b);for(let a=b;a<c;a++)d[a-b]=this.getElement(a);return d}getElement(a){a=parseInt(a);let b=Math.floor(a/262144),c=a%262144;return this.arr[b]?this.arr[b][c]:void 0}setElement(a,c){a=parseInt(a);let b=Math.floor(a/262144);this.arr[b]||(this.arr[b]=Array(262144));let d=a%262144;return this.arr[b][d]=c,a>=this.length&&(this.length=a+1),!0}getKeys(){let c=new bl;for(let a=0;a<this.arr.length;a++)if(this.arr[a])for(let b=0;b<this.arr[a].length;b++)void 0!==this.arr[a][b]&&c.push(262144*a+b);return c}}(a),c=new Proxy(b,{get:function(b,a){return isNaN(a)?b[a]:b.getElement(a)},set:function(b,a,c){return isNaN(a)?(b[a]=c,!0):b.setElement(a,c)}});return c}}async function L(E,F,G,c){await ag.default.ready();let k=ag.default(64),{fd:g,sections:i}=await h.readBinFile(F,"ptau",1,4194304,16777216),{curve:d,power:w}=await a2(g,i),{fd:q,sections:x}=await h.readBinFile(E,"r1cs",1,4194304,16777216),e=await ae.readR1csHeader(q,x,!1),b=await h.createBinFile(G,"zkey",1,10,4194304,16777216),f=2*d.G1.F.n8,l=2*d.G2.F.n8;if(e.prime!=d.r)return c&&c.error("r1cs curve does not match powers of tau ceremony curve"),-1;let y=ao(e.nConstraints+e.nPubInputs+e.nOutputs+1-1)+1;if(y>w)return c&&c.error(`circuit too big for this power of tau ceremony. ${e.nConstraints}*2 > 2**${w}`),-1;if(!i[12])return c&&c.error("Powers of tau is not prepared."),-1;let r=e.nOutputs+e.nPubInputs,j=2**y;await h.startWriteSection(b,1),await b.writeULE32(1),await h.endWriteSection(b),await h.startWriteSection(b,2);let z=d.q,A=(Math.floor((a.Scalar.bitLength(z)-1)/64)+1)*8,m=d.r,s=(Math.floor((a.Scalar.bitLength(m)-1)/64)+1)*8,B=a.Scalar.mod(a.Scalar.shl(1,8*s),m),M=d.Fr.e(a.Scalar.mod(a.Scalar.mul(B,B),m));await b.writeULE32(A),await h.writeBigInt(b,z,A),await b.writeULE32(s),await h.writeBigInt(b,m,s),await b.writeULE32(e.nVars),await b.writeULE32(r),await b.writeULE32(j);let n;await b.write(n=await g.read(f,i[4][0].p)),n=await d.G1.batchLEMtoU(n),k.update(n);let o;await b.write(o=await g.read(f,i[5][0].p)),o=await d.G1.batchLEMtoU(o),k.update(o);let p;await b.write(p=await g.read(l,i[6][0].p)),p=await d.G2.batchLEMtoU(p),k.update(p);let C=new Uint8Array(f);d.G1.toRprLEM(C,0,d.G1.g);let t=new Uint8Array(l);d.G2.toRprLEM(t,0,d.G2.g);let D=new Uint8Array(f);d.G1.toRprUncompressed(D,0,d.G1.g);let u=new Uint8Array(l);d.G2.toRprUncompressed(u,0,d.G2.g),await b.write(t),await b.write(C),await b.write(t),k.update(u),k.update(D),k.update(u),await h.endWriteSection(b),c&&c.info("Reading r1cs");let N=await h.readSection(q,x,2),H=new bl(e.nVars),I=new bl(e.nVars),J=new bl(e.nVars),K=new bl(e.nVars-r-1),L=Array(r+1);c&&c.info("Reading tauG1");let O=await h.readSection(g,i,12,(j-1)*f,j*f);c&&c.info("Reading tauG2");let P=await h.readSection(g,i,13,(j-1)*l,j*l);c&&c.info("Reading alphatauG1");let Q=await h.readSection(g,i,14,(j-1)*f,j*f);c&&c.info("Reading betatauG1");let R=await h.readSection(g,i,15,(j-1)*f,j*f);await T(),await U(3,"G1",L,"IC"),await S(),await W(),await U(8,"G1",K,"C"),await U(5,"G1",H,"A"),await U(6,"G1",I,"B1"),await U(7,"G2",J,"B2");let v=k.digest();return await h.startWriteSection(b,10),await b.write(v),await b.writeULE32(0),await h.endWriteSection(b),c&&c.info(ap(v,"Circuit hash: ")),await b.close(),await q.close(),await g.close(),v;async function S(){await h.startWriteSection(b,9);let k=new a.BigBuffer(j*f);if(y<d.Fr.s){let l=await h.readSection(g,i,12,(2*j-1)*f,2*j*f);for(let e=0;e<j;e++){c&&e%1e4==0&&c.debug(`spliting buffer: ${e}/${j}`);let m=l.slice((2*e+1)*f,(2*e+1)*f+f);k.set(m,e*f)}}else if(y==d.Fr.s){let n=i[12][0].p+(2**(y+1)-1)*f;await g.readToBuffer(k,0,j*f,n+j*f)}else throw c&&c.error("Circuit too big"),Error("Circuit too big for this curve");await b.write(k),await h.endWriteSection(b)}async function T(){let G=new Uint8Array(12+d.Fr.n8),ab=new DataView(G.buffer),O=new Uint8Array(d.Fr.n8);d.Fr.toRprLE(O,0,d.Fr.e(1));let o=0;function p(){let a=N.slice(o,o+4);o+=4;let b=new DataView(a.buffer);return b.getUint32(0,!0)}let m=new bl;for(let i=0;i<e.nConstraints;i++){c&&i%1e4==0&&c.debug(`processing constraints: ${i}/${e.nConstraints}`);let P=p();for(let u=0;u<P;u++){let k=p(),t=o;o+=d.Fr.n8;let Q=0,R=f*i,v=3,w=f*i;void 0===H[k]&&(H[k]=[]),H[k].push([Q,R,t]),k<=r?(void 0===L[k]&&(L[k]=[]),L[k].push([v,w,t])):(void 0===K[k-r-1]&&(K[k-r-1]=[]),K[k-r-1].push([v,w,t])),m.push([0,i,k,t])}let S=p();for(let x=0;x<S;x++){let g=p(),q=o;o+=d.Fr.n8;let T=0,U=f*i,V=1,W=l*i,y=2,z=f*i;void 0===I[g]&&(I[g]=[]),I[g].push([T,U,q]),void 0===J[g]&&(J[g]=[]),J[g].push([V,W,q]),g<=r?(void 0===L[g]&&(L[g]=[]),L[g].push([y,z,q])):(void 0===K[g-r-1]&&(K[g-r-1]=[]),K[g-r-1].push([y,z,q])),m.push([1,i,g,q])}let X=p();for(let A=0;A<X;A++){let n=p(),B=o;o+=d.Fr.n8;let C=0,D=f*i;n<=r?(void 0===L[n]&&(L[n]=[]),L[n].push([C,D,B])):(void 0===K[n-r-1]&&(K[n-r-1]=[]),K[n-r-1].push([C,D,B]))}}for(let j=0;j<=r;j++){let Y=0,Z=f*(e.nConstraints+j),$=3,_=f*(e.nConstraints+j);void 0===H[j]&&(H[j]=[]),H[j].push([Y,Z,-1]),void 0===L[j]&&(L[j]=[]),L[j].push([$,_,-1]),m.push([0,e.nConstraints+j,j,-1])}await h.startWriteSection(b,4);let E=new a.BigBuffer(m.length*(12+d.Fr.n8)+4),F=new Uint8Array(4),aa=new DataView(F.buffer);aa.setUint32(0,m.length,!0),E.set(F);let ac=4;for(let s=0;s<m.length;s++)c&&s%1e5==0&&c.debug(`writing coeffs: ${s}/${m.length}`),ad(m[s]);function ad(a){ab.setUint32(0,a[0],!0),ab.setUint32(4,a[1],!0),ab.setUint32(8,a[2],!0);let b;b=a[3]>=0?d.Fr.fromRprLE(N.slice(a[3],a[3]+d.Fr.n8),0):d.Fr.fromRprLE(O,0);let c=d.Fr.mul(b,M);d.Fr.toRprLE(G,12,c),E.set(G,ac),ac+=G.length}await b.write(E),await h.endWriteSection(b)}async function U(p,l,e,m){let q=d[l];Z(e.length),await h.startWriteSection(b,p);let i=[],a=0;for(;a<e.length;){let n=0;for(;a<e.length&&n<d.tm.concurrency;){c&&c.debug(`Writing points start ${m}: ${a}/${e.length}`);let f=1,o=e[a]?e[a].length:0;for(;a+f<e.length&&o+(e[a+f]?e[a+f].length:0)<32768&&f<32768;)o+=e[a+f]?e[a+f].length:0,f++;let r=e.slice(a,a+f),t=a;i.push(V(l,r,c,m).then(a=>(c&&c.debug(`Writing points end ${m}: ${t}/${e.length}`),a))),a+=f,n++}let j=await Promise.all(i);for(let g=0;g<j.length;g++){await b.write(j[g][0]);let s=await q.batchLEMtoU(j[g][0]);k.update(s)}i=[]}await h.endWriteSection(b)}async function V(r,b,s,y){let j=d[r],k=2*j.F.n8,t=3*j.F.n8,A=2*j.F.n8,u,v,w,x;if("G1"==r)u="g1m_timesScalarAffine",v="g1m_multiexpAffine",w="g1m_batchToAffine",x="g1m_zero";else if("G2"==r)u="g2m_timesScalarAffine",v="g2m_multiexpAffine",w="g2m_batchToAffine",x="g2m_zero";else throw Error("Invalid group");let h=0;for(let n=0;n<b.length;n++)h+=b[n]?b[n].length:0;let l,i;h>32768?(l=new a.BigBuffer(h*k),i=new a.BigBuffer(h*d.Fr.n8)):(l=new Uint8Array(h*k),i=new Uint8Array(h*d.Fr.n8));let o=0,p=0,B=[O,P,Q,R],z=new Uint8Array(d.Fr.n8);d.Fr.toRprLE(z,0,d.Fr.e(1));let q=0;for(let c=0;c<b.length;c++)if(b[c])for(let e=0;e<b[c].length;e++)s&&e&&e%1e4==0&&s.debug(`Configuring big array ${y}: ${e}/${b[c].length}`),l.set(B[b[c][e][0]].slice(b[c][e][1],b[c][e][1]+k),q*k),b[c][e][2]>=0?i.set(N.slice(b[c][e][2],b[c][e][2]+d.Fr.n8),q*d.Fr.n8):i.set(z,q*d.Fr.n8),q++;if(b.length>1){let f=[];f.push({cmd:"ALLOCSET",var:0,buff:l}),f.push({cmd:"ALLOCSET",var:1,buff:i}),f.push({cmd:"ALLOC",var:2,len:b.length*t}),o=0,p=0;let m=0;for(let g=0;g<b.length;g++){if(!b[g]){f.push({cmd:"CALL",fnName:x,params:[{var:2,offset:m}]}),m+=t;continue}1==b[g].length?f.push({cmd:"CALL",fnName:u,params:[{var:0,offset:o},{var:1,offset:p},{val:d.Fr.n8},{var:2,offset:m}]}):f.push({cmd:"CALL",fnName:v,params:[{var:0,offset:o},{var:1,offset:p},{val:d.Fr.n8},{val:b[g].length},{var:2,offset:m}]}),o+=k*b[g].length,p+=d.Fr.n8*b[g].length,m+=t}f.push({cmd:"CALL",fnName:w,params:[{var:2},{val:b.length},{var:2},]}),f.push({cmd:"GET",out:0,var:2,len:b.length*A});let C=await d.tm.queueAction(f);return C}{let D=await j.multiExpAffine(l,i,s,y);return[j.toAffine(D)]}}async function W(){Z(j-1);for(let a=0;a<j-1;a+=16384){c&&c.debug(`HashingHPoints: ${a}/${j}`);let b=Math.min(j-1,16384);await X(a,b)}}async function X(m,c){let p=await g.read(c*f,i[2][0].p+(m+j)*f),q=await g.read(c*f,i[2][0].p+m*f),e=d.tm.concurrency,b=Math.floor(c/e),n=[];for(let a=0;a<e;a++){let h;if(0==(h=a<e-1?b:c-a*b))continue;let r=p.slice(a*b*f,(a*b+h)*f),s=q.slice(a*b*f,(a*b+h)*f);n.push(Y(r,s))}let o=await Promise.all(n);for(let l=0;l<o.length;l++)k.update(o[l][0])}async function Y(e,h){let b=e.byteLength/f,g=3*d.G1.F.n8,a=[];a.push({cmd:"ALLOCSET",var:0,buff:e}),a.push({cmd:"ALLOCSET",var:1,buff:h}),a.push({cmd:"ALLOC",var:2,len:b*g});for(let c=0;c<b;c++)a.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:c*f},{var:1,offset:c*f},{var:2,offset:c*g},]});a.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:b},{var:2},]}),a.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:b},{var:2},]}),a.push({cmd:"GET",out:0,var:2,len:b*f});let i=await d.tm.queueAction(a);return i}function Z(b){let a=new Uint8Array(4),c=new DataView(a.buffer,a.byteOffset,a.byteLength);c.setUint32(0,b,!1),k.update(a)}}async function M(o,p,j){let{fd:b,sections:e}=await af.readBinFile(o,"zkey",2),c=await aD(b,e);if("groth16"!=c.protocol)throw Error("zkey file is not groth16");let a=await am(c.q),q=2*a.G1.F.n8,s=2*a.G2.F.n8,g=await aI(b,a,e),h=await ai.createOverride(p);await u(c.vk_alpha_1),await u(c.vk_beta_1),await v(c.vk_beta_2),await v(c.vk_gamma_2),await u(c.vk_delta_1),await v(c.vk_delta_2);let t;await w("G1",await a.G1.batchLEMtoU(await af.readSection(b,e,3)));let r=await af.readSection(b,e,9),d;d=await a.G1.fft(r,"affine","jacobian",j),d=await a.G1.batchApplyKey(d,a.Fr.neg(a.Fr.e(2)),a.Fr.w[c.power+1],"jacobian","affine",j),d=d.slice(0,d.byteLength-q),d=await a.G1.batchLEMtoU(d),await w("G1",d);let k;await w("G1",k=await a.G1.batchLEMtoU(k=await af.readSection(b,e,8)));let l;await w("G1",l=await a.G1.batchLEMtoU(l=await af.readSection(b,e,5)));let m;await w("G1",m=await a.G1.batchLEMtoU(m=await af.readSection(b,e,6)));let n;await w("G2",n=await a.G2.batchLEMtoU(n=await af.readSection(b,e,7))),await h.write(g.csHash),await x(g.contributions.length);for(let i=0;i<g.contributions.length;i++){let f=g.contributions[i];await u(f.deltaAfter),await u(f.delta.g1_s),await u(f.delta.g1_sx),await v(f.delta.g2_spx),await h.write(f.transcript)}async function u(c){let b=new Uint8Array(q);a.G1.toRprUncompressed(b,0,c),await h.write(b)}async function v(c){let b=new Uint8Array(s);a.G2.toRprUncompressed(b,0,c),await h.write(b)}async function w(d,b){let c;c="G1"==d?q:s;let a=new Uint8Array(4),e=new DataView(a.buffer,a.byteOffset,a.byteLength);e.setUint32(0,b.byteLength/c,!1),await h.write(a),await h.write(b)}async function x(b){let a=new Uint8Array(4),c=new DataView(a.buffer,a.byteOffset,a.byteLength);c.setUint32(0,b,!1),await h.write(a)}await b.close(),await h.close()}async function N(s,t,u,r,c){let{fd:j,sections:l}=await af.readBinFile(s,"zkey",2),b=await aD(j,l,!1);if("groth16"!=b.protocol)throw Error("zkey file is not groth16");let e=await am(b.q),f=2*e.G1.F.n8,n=2*e.G2.F.n8,g=await aI(j,e,l),i={},a=await ai.readExisting(t);a.pos=3*f+3*n+8+f*b.nVars+4+f*(b.domainSize-1)+4+f*b.nVars+4+f*b.nVars+4+n*b.nVars,i.csHash=await a.read(64);let v=await a.readUBE32();i.contributions=[];for(let k=0;k<v;k++){let h={delta:{}};h.deltaAfter=await G(a),h.delta.g1_s=await G(a),h.delta.g1_sx=await G(a),h.delta.g2_spx=await H(a),h.transcript=await a.read(64),k<g.contributions.length&&(h.type=g.contributions[k].type,1==h.type&&(h.beaconHash=g.contributions[k].beaconHash,h.numIterationsExp=g.contributions[k].numIterationsExp),g.contributions[k].name&&(h.name=g.contributions[k].name)),i.contributions.push(h)}if(!aq(i.csHash,g.csHash))return c&&c.error("Hash of the original circuit does not match with the MPC one"),!1;if(g.contributions.length>i.contributions.length)return c&&c.error("The impoerted file does not include new contributions"),!1;for(let o=0;o<g.contributions.length;o++)if(!I(g.contributions[o],i.contributions[o]))return c&&c.error(`Previos contribution ${o} does not match`),!1;if(r)for(let p=g.contributions.length;p<i.contributions.length;p++)i.contributions[p].name=r;let d=await af.createBinFile(u,"zkey",1,10);a.pos=0,a.pos+=f,a.pos+=f,a.pos+=n,a.pos+=n,b.vk_delta_1=await G(a),b.vk_delta_2=await H(a),await ay(d,b);let w=await a.readUBE32();if(w!=b.nPublic+1)return c&&c.error("Invalid number of points in IC"),await d.discard(),!1;a.pos+=f*(b.nPublic+1),await af.copySection(j,l,d,3),await af.copySection(j,l,d,4);let x=await a.readUBE32();if(x!=b.domainSize-1)return c&&c.error("Invalid number of points in H"),await d.discard(),!1;let m,y=await a.read(f*(b.domainSize-1)),z=await e.G1.batchUtoLEM(y);(m=new Uint8Array(b.domainSize*f)).set(z),e.G1.toRprLEM(m,f*(b.domainSize-1),e.G1.zeroAffine);let A=e.Fr.neg(e.Fr.inv(e.Fr.e(2))),B=e.Fr.inv(e.Fr.w[b.power+1]);m=await e.G1.batchApplyKey(m,A,B,"affine","jacobian",c),m=await e.G1.ifft(m,"jacobian","affine",c),await af.startWriteSection(d,9),await d.write(m),await af.endWriteSection(d);let C=await a.readUBE32();if(C!=b.nVars-b.nPublic-1)return c&&c.error("Invalid number of points in L"),await d.discard(),!1;let q;q=await e.G1.batchUtoLEM(q=await a.read(f*(b.nVars-b.nPublic-1))),await af.startWriteSection(d,8),await d.write(q),await af.endWriteSection(d);let D=await a.readUBE32();if(D!=b.nVars)return c&&c.error("Invalid number of points in A"),await d.discard(),!1;a.pos+=f*b.nVars,await af.copySection(j,l,d,5);let E=await a.readUBE32();if(E!=b.nVars)return c&&c.error("Invalid number of points in B1"),await d.discard(),!1;a.pos+=f*b.nVars,await af.copySection(j,l,d,6);let F=await a.readUBE32();if(F!=b.nVars)return c&&c.error("Invalid number of points in B2"),await d.discard(),!1;return a.pos+=n*b.nVars,await af.copySection(j,l,d,7),await aK(d,e,i),await a.close(),await d.close(),await j.close(),!0;async function G(a){let b=await a.read(2*e.G1.F.n8);return e.G1.fromRprUncompressed(b,0)}async function H(a){let b=await a.read(2*e.G2.F.n8);return e.G2.fromRprUncompressed(b,0)}function I(a,b){return!!(e.G1.eq(a.deltaAfter,b.deltaAfter)&&e.G1.eq(a.delta.g1_s,b.delta.g1_s)&&e.G1.eq(a.delta.g1_sx,b.delta.g1_sx)&&e.G2.eq(a.delta.g2_spx,b.delta.g2_spx)&&aq(a.transcript,b.transcript))}}let bm=g;async function O(x,C,y,b){let n;await ag.default.ready();let{fd:h,sections:g}=await af.readBinFile(y,"zkey",2),d=await aD(h,g,!1);if("groth16"!=d.protocol)throw Error("zkey file is not groth16");let c=await am(d.q),s=2*c.G1.F.n8,l=await aI(h,c,g),q=ag.default(64);q.update(l.csHash);let o=c.G1.g;for(let j=0;j<l.contributions.length;j++){let e=l.contributions[j],r=ar(q);if(aL(r,c,e.delta.g1_s),aL(r,c,e.delta.g1_sx),!aq(r.digest(),e.transcript))return console.log(`INVALID(${j}): Inconsistent transcript `),!1;let t=aZ(c,e.transcript);if(!0!==(n=await bm(c,e.delta.g1_s,e.delta.g1_sx,t,e.delta.g2_spx)))return console.log(`INVALID(${j}): public key G1 and G2 do not have the same ration `),!1;if(!0!==(n=await bm(c,o,e.deltaAfter,t,e.delta.g2_spx)))return console.log(`INVALID(${j}): deltaAfter does not fillow the public key `),!1;if(1==e.type){let u=au(e.beaconHash,e.numIterationsExp),z=c.Fr.fromRng(u),v=c.G1.toAffine(c.G1.fromRng(u)),A=c.G1.toAffine(c.G1.timesFr(v,z));if(!0!==c.G1.eq(v,e.delta.g1_s))return console.log(`INVALID(${j}): Key of the beacon does not match. g1_s `),!1;if(!0!==c.G1.eq(A,e.delta.g1_sx))return console.log(`INVALID(${j}): Key of the beacon does not match. g1_sx `),!1}aM(q,c,e);let w=ag.default(64);aM(w,c,e),e.contributionHash=w.digest(),o=e.deltaAfter}let{fd:i,sections:k}=await af.readBinFile(x,"zkey",2),f=await aD(i,k,!1);if("groth16"!=f.protocol)throw Error("zkeyinit file is not groth16");if(!a.Scalar.eq(f.q,d.q)||!a.Scalar.eq(f.r,d.r)||f.n8q!=d.n8q||f.n8r!=d.n8r)return b&&b.error("INVALID:  Different curves"),!1;if(f.nVars!=d.nVars||f.nPublic!=d.nPublic||f.domainSize!=d.domainSize)return b&&b.error("INVALID:  Different circuit parameters"),!1;if(!c.G1.eq(d.vk_alpha_1,f.vk_alpha_1))return b&&b.error("INVALID:  Invalid alpha1"),!1;if(!c.G1.eq(d.vk_beta_1,f.vk_beta_1))return b&&b.error("INVALID:  Invalid beta1"),!1;if(!c.G2.eq(d.vk_beta_2,f.vk_beta_2))return b&&b.error("INVALID:  Invalid beta2"),!1;if(!c.G2.eq(d.vk_gamma_2,f.vk_gamma_2))return b&&b.error("INVALID:  Invalid gamma2"),!1;if(!c.G1.eq(d.vk_delta_1,o))return b&&b.error("INVALID:  Invalid delta1"),!1;if(!0!==(n=await bm(c,c.G1.g,o,c.G2.g,d.vk_delta_2)))return b&&b.error("INVALID:  Invalid delta2"),!1;let B=await aI(i,c,k);if(!aq(l.csHash,B.csHash))return b&&b.error("INVALID:  Circuit does not match"),!1;if(g[8][0].size!=s*(d.nVars-d.nPublic-1))return b&&b.error("INVALID:  Invalid L section size"),!1;if(g[9][0].size!=s*d.domainSize)return b&&b.error("INVALID:  Invalid H section size"),!1;let D;if(!await af.sectionIsEqual(h,g,i,k,3))return b&&b.error("INVALID:  IC section is not identical"),!1;if(!await af.sectionIsEqual(h,g,i,k,4))return b&&b.error("Coeffs section is not identical"),!1;if(!await af.sectionIsEqual(h,g,i,k,5))return b&&b.error("A section is not identical"),!1;if(!await af.sectionIsEqual(h,g,i,k,6))return b&&b.error("B1 section is not identical"),!1;if(!await af.sectionIsEqual(h,g,i,k,7))return b&&b.error("B2 section is not identical"),!1;if(!0!==(n=await E("G1",i,k,h,g,8,d.vk_delta_2,f.vk_delta_2,"L section")))return b&&b.error("L section does not match"),!1;if(!0!==(n=await F()))return b&&b.error("H section does not match"),!1;b&&b.info(ap(l.csHash,"Circuit Hash: ")),await h.close(),await i.close();for(let p=l.contributions.length-1;p>=0;p--){let m=l.contributions[p];b&&b.info("-------------------------"),b&&b.info(ap(m.contributionHash,`contribution #${p+1} ${m.name?m.name:""}:`)),1==m.type&&(b&&b.info(`Beacon generator: ${aw(m.beaconHash)}`),b&&b.info(`Beacon iterations Exp: ${m.numIterationsExp}`))}return b&&b.info("-------------------------"),b&&b.info("ZKey Ok!"),!0;async function E(p,f,o,g,q,h,r,s,t){let a=c[p],i=2*a.F.n8;await af.startReadUniqueSection(f,o,h),await af.startReadUniqueSection(g,q,h);let j=a.zero,k=a.zero,d=o[h][0].size/i;for(let e=0;e<d;e+=1048576){b&&b.debug(`Same ratio check ${t}:  ${e}/${d}`);let l=Math.min(d-e,1048576),u=await f.read(l*i),v=await g.read(l*i),m=new Uint8Array(4*l);ah.default.randomFillSync(m);let w=await a.multiExpAffine(u,m),x=await a.multiExpAffine(v,m);j=a.add(j,w),k=a.add(k,x)}return await af.endReadSection(f),await af.endReadSection(g),0==d|| !0===(n=await bm(c,j,k,r,s))}async function F(){let o=1048576,k=c.G1,e=c.Fr,l=2*k.F.n8,{fd:v,sections:w}=await af.readBinFile(C,"ptau",1),i=new a.BigBuffer(d.domainSize*d.n8r),x=Array(8);for(let p=0;p<8;p++)x[p]=ah.default.randomBytes(4).readUInt32BE(0,!0);let z=new a.ChaCha(x);for(let q=0;q<d.domainSize-1;q++){let A=e.fromRng(z);e.toRprLE(i,q*d.n8r,A)}e.toRprLE(i,(d.domainSize-1)*d.n8r,e.zero);let r=k.zero;for(let j=0;j<d.domainSize;j+=o){b&&b.debug(`H Verificaition(tau):  ${j}/${d.domainSize}`);let s=Math.min(d.domainSize-j,o),B=await v.read(l*s,w[2][0].p+d.domainSize*l+j*l),D=await v.read(l*s,w[2][0].p+j*l),E=await G(B,D),F=i.slice(j*d.n8r,(j+s)*d.n8r),H=await k.multiExpAffine(E,F);r=k.add(r,H)}i=await e.batchToMontgomery(i);let t;if(d.power<e.s)t=e.neg(e.e(2));else{let I=2**e.s,J=e.exp(e.shift,I);t=e.sub(J,e.one)}let K=d.power<e.s?e.w[d.power+1]:e.shift;i=await e.batchApplyKey(i,t,K),i=await e.fft(i),i=await e.batchFromMontgomery(i),await af.startReadUniqueSection(h,g,9);let u=k.zero;for(let m=0;m<d.domainSize;m+=o){b&&b.debug(`H Verificaition(lagrange):  ${m}/${d.domainSize}`);let y=Math.min(d.domainSize-m,o),L=await h.read(l*y),M=i.slice(m*d.n8r,(m+y)*d.n8r),N=await k.multiExpAffine(L,M);u=k.add(u,N)}return await af.endReadSection(h),!0===(n=await bm(c,r,u,d.vk_delta_2,f.vk_delta_2))}async function G(i,n){let j=2*c.G1.F.n8,e=i.byteLength/j,f=c.tm.concurrency,b=Math.floor(e/f),k=[];for(let a=0;a<f;a++){let g;if(0==(g=a<f-1?b:e-a*b))continue;let o=i.slice(a*b*s,(a*b+g)*s),p=n.slice(a*b*s,(a*b+g)*s);k.push(H(o,p))}let h=await Promise.all(k),l=new Uint8Array(e*j),m=0;for(let d=0;d<h.length;d++)l.set(h[d][0],m),m+=h[d][0].byteLength;return l}async function H(f,h){let d=2*c.G1.F.n8,g=3*c.G1.F.n8,e=f.byteLength/d,a=[];a.push({cmd:"ALLOCSET",var:0,buff:f}),a.push({cmd:"ALLOCSET",var:1,buff:h}),a.push({cmd:"ALLOC",var:2,len:e*g});for(let b=0;b<e;b++)a.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:b*d},{var:1,offset:b*d},{var:2,offset:b*g},]});a.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:e},{var:2},]}),a.push({cmd:"GET",out:0,var:2,len:e*d});let i=await c.tm.queueAction(a);return i}}async function P(d,a,e,b){let c={type:"bigMem"};return await L(d,a,c,b),await O(c,a,e,b)}async function Q(p,q,k,r,g){await ag.default.ready();let{fd:c,sections:e}=await af.readBinFile(p,"zkey",2),f=await aD(c,e);if("groth16"!=f.protocol)throw Error("zkey file is not groth16");let b=await am(f.q),h=await aI(c,b,e),d=await af.createBinFile(q,"zkey",1,10),l=await at(r),i=ag.default(64);i.update(h.csHash);for(let j=0;j<h.contributions.length;j++)aM(i,b,h.contributions[j]);let a={};a.delta={},a.delta.prvKey=b.Fr.fromRng(l),a.delta.g1_s=b.G1.toAffine(b.G1.fromRng(l)),a.delta.g1_sx=b.G1.toAffine(b.G1.timesFr(a.delta.g1_s,a.delta.prvKey)),aL(i,b,a.delta.g1_s),aL(i,b,a.delta.g1_sx),a.transcript=i.digest(),a.delta.g2_sp=aZ(b,a.transcript),a.delta.g2_spx=b.G2.toAffine(b.G2.timesFr(a.delta.g2_sp,a.delta.prvKey)),f.vk_delta_1=b.G1.timesFr(f.vk_delta_1,a.delta.prvKey),f.vk_delta_2=b.G2.timesFr(f.vk_delta_2,a.delta.prvKey),a.deltaAfter=f.vk_delta_1,a.type=0,k&&(a.name=k),h.contributions.push(a),await ay(d,f),await af.copySection(c,e,d,3),await af.copySection(c,e,d,4),await af.copySection(c,e,d,5),await af.copySection(c,e,d,6),await af.copySection(c,e,d,7);let m=b.Fr.inv(a.delta.prvKey);await bf(c,e,d,8,b,"G1",m,b.Fr.e(1),"L Section",g),await bf(c,e,d,9,b,"G1",m,b.Fr.e(1),"H Section",g),await aK(d,b,h),await c.close(),await d.close();let n=ag.default(64);aM(n,b,a);let o=n.digest();return g&&g.info(ap(h.csHash,"Circuit Hash: ")),g&&g.info(ap(o,"Contribution Hash: ")),o}async function R(s,t,m,n,h,c){await ag.default.ready();let i=av(n);if(0==i.byteLength||2*i.byteLength!=n.length)return c&&c.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(i.length>=256)return c&&c.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((h=parseInt(h))<10||h>63)return c&&c.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;let{fd:d,sections:f}=await af.readBinFile(s,"zkey",2),g=await aD(d,f);if("groth16"!=g.protocol)throw Error("zkey file is not groth16");let b=await am(g.q),j=await aI(d,b,f),e=await af.createBinFile(t,"zkey",1,10),o=await au(i,h),k=ag.default(64);k.update(j.csHash);for(let l=0;l<j.contributions.length;l++)aM(k,b,j.contributions[l]);let a={};a.delta={},a.delta.prvKey=b.Fr.fromRng(o),a.delta.g1_s=b.G1.toAffine(b.G1.fromRng(o)),a.delta.g1_sx=b.G1.toAffine(b.G1.timesFr(a.delta.g1_s,a.delta.prvKey)),aL(k,b,a.delta.g1_s),aL(k,b,a.delta.g1_sx),a.transcript=k.digest(),a.delta.g2_sp=aZ(b,a.transcript),a.delta.g2_spx=b.G2.toAffine(b.G2.timesFr(a.delta.g2_sp,a.delta.prvKey)),g.vk_delta_1=b.G1.timesFr(g.vk_delta_1,a.delta.prvKey),g.vk_delta_2=b.G2.timesFr(g.vk_delta_2,a.delta.prvKey),a.deltaAfter=g.vk_delta_1,a.type=1,a.numIterationsExp=h,a.beaconHash=i,m&&(a.name=m),j.contributions.push(a),await ay(e,g),await af.copySection(d,f,e,3),await af.copySection(d,f,e,4),await af.copySection(d,f,e,5),await af.copySection(d,f,e,6),await af.copySection(d,f,e,7);let p=b.Fr.inv(a.delta.prvKey);await bf(d,f,e,8,b,"G1",p,b.Fr.e(1),"L Section",c),await bf(d,f,e,9,b,"G1",p,b.Fr.e(1),"H Section",c),await aK(e,b,j),await d.close(),await e.close();let q=ag.default(64);aM(q,b,a);let r=q.digest();return c&&c.info(ap(r,"Contribution Hash: ")),r}async function S(c){let b=await aG(c,!0);return delete b.curve,delete b.F,a.utils.stringifyBigInts(b)}async function T(a,z,A,B,k){await ag.default.ready();let n=await at(B),g=a.Fr.fromRng(n),o=a.Fr.inv(g),h=2*a.G1.F.n8,l=2*a.G2.F.n8,c=await ai.readExisting(z),d=await ai.createOverride(A);await G(h),await G(h),await G(l),await G(l);let C=await H(),p=a.G1.timesFr(C,g);await J(p);let D=await I(),E=a.G2.timesFr(D,g);await K(E);let q=await c.readUBE32();await d.writeUBE32(q),await G(q*h);let r=await c.readUBE32();await d.writeUBE32(r),await bg(c,d,null,a,"G1",r,o,a.Fr.e(1),"UNCOMPRESSED","H",k);let s=await c.readUBE32();await d.writeUBE32(s),await bg(c,d,null,a,"G1",s,o,a.Fr.e(1),"UNCOMPRESSED","L",k);let t=await c.readUBE32();await d.writeUBE32(t),await G(t*h);let u=await c.readUBE32();await d.writeUBE32(u),await G(u*h);let v=await c.readUBE32();await d.writeUBE32(v),await G(v*l);let i=ag.default(64),e={};e.csHash=await c.read(64),i.update(e.csHash);let F=await c.readUBE32();e.contributions=[];for(let w=0;w<F;w++){let f={delta:{}};f.deltaAfter=await H(),f.delta.g1_s=await H(),f.delta.g1_sx=await H(),f.delta.g2_spx=await I(),f.transcript=await c.read(64),e.contributions.push(f),aM(i,a,f)}let b={};b.delta={},b.delta.prvKey=g,b.delta.g1_s=a.G1.toAffine(a.G1.fromRng(n)),b.delta.g1_sx=a.G1.toAffine(a.G1.timesFr(b.delta.g1_s,g)),aL(i,a,b.delta.g1_s),aL(i,a,b.delta.g1_sx),b.transcript=i.digest(),b.delta.g2_sp=aZ(a,b.transcript),b.delta.g2_spx=a.G2.toAffine(a.G2.timesFr(b.delta.g2_sp,g)),b.deltaAfter=p,b.type=0,e.contributions.push(b),await d.write(e.csHash),await d.writeUBE32(e.contributions.length);for(let m=0;m<e.contributions.length;m++){let j=e.contributions[m];await J(j.deltaAfter),await J(j.delta.g1_s),await J(j.delta.g1_sx),await K(j.delta.g2_spx),await d.write(j.transcript)}let x=ag.default(64);aM(x,a,b);let y=x.digest();return k&&k.info(ap(y,"Contribution Hash: ")),await d.close(),await c.close(),y;async function G(b){let e=2*c.pageSize;for(let a=0;a<b;a+=e){let f=Math.min(b-a,e),g=await c.read(f);await d.write(g)}}async function H(){let b=await c.read(2*a.G1.F.n8);return a.G1.fromRprUncompressed(b,0)}async function I(){let b=await c.read(2*a.G2.F.n8);return a.G2.fromRprUncompressed(b,0)}async function J(c){let b=new Uint8Array(h);a.G1.toRprUncompressed(b,0,c),await d.write(b)}async function K(c){let b=new Uint8Array(l);a.G2.toRprUncompressed(b,0,c),await d.write(b)}}let{stringifyBigInts:bn}=a.utils;async function U(e){let{fd:b,sections:d}=await af.readBinFile(e,"zkey",2),a=await aD(b,d),c;if("groth16"==a.protocol)c=await bo(a,b,d);else if("plonk"==a.protocol)c=await bp(a);else throw Error("zkey file is not groth16");return await b.close(),c}async function bo(a,d,f){let b=await am(a.q),g=2*b.G1.F.n8,h=await b.pairing(a.vk_alpha_1,a.vk_beta_2),c={protocol:a.protocol,curve:b.name,nPublic:a.nPublic,vk_alpha_1:b.G1.toObject(a.vk_alpha_1),vk_beta_2:b.G2.toObject(a.vk_beta_2),vk_gamma_2:b.G2.toObject(a.vk_gamma_2),vk_delta_2:b.G2.toObject(a.vk_delta_2),vk_alphabeta_12:b.Gt.toObject(h)};await af.startReadUniqueSection(d,f,3),c.IC=[];for(let e=0;e<=a.nPublic;e++){let i=await d.read(g),j=b.G1.toObject(i);c.IC.push(j)}return await af.endReadSection(d),c=bn(c)}async function bp(a){let b=await am(a.q),c={protocol:a.protocol,curve:b.name,nPublic:a.nPublic,power:a.power,k1:b.Fr.toObject(a.k1),k2:b.Fr.toObject(a.k2),Qm:b.G1.toObject(a.Qm),Ql:b.G1.toObject(a.Ql),Qr:b.G1.toObject(a.Qr),Qo:b.G1.toObject(a.Qo),Qc:b.G1.toObject(a.Qc),S1:b.G1.toObject(a.S1),S2:b.G1.toObject(a.S2),S3:b.G1.toObject(a.S3),X_2:b.G2.toObject(a.X_2),w:b.Fr.toObject(b.Fr.w[a.power])};return bn(c)}async function V(b,c,e){let a=await U(b),d=c[a.protocol];return aj.default.render(d,a)}var W=Object.freeze({__proto__:null,newZKey:L,exportBellman:M,importBellman:N,verifyFromR1cs:P,verifyFromInit:O,contribute:Q,beacon:R,exportJson:S,bellmanContribute:T,exportVerificationKey:U,exportSolidityVerifier:V});async function X(q,r,s,b){globalThis.gc&&globalThis.gc(),await ag.default.ready();let{fd:f,sections:g}=await h.readBinFile(r,"ptau",1,4194304,16777216),{curve:c,power:n}=await a2(f,g),{fd:l,sections:o}=await h.readBinFile(q,"r1cs",1,4194304,16777216),i=await ae.readR1csHeader(l,o,!1),d=2*c.G1.F.n8,w=c.G1,x=2*c.G2.F.n8,y=c.Fr,z=c.Fr.n8;b&&b.info("Reading r1cs");let A=await h.readSection(l,o,2),m=new bl,B=new bl,C=i.nVars,D=i.nOutputs+i.nPubInputs;await H(),globalThis.gc&&globalThis.gc();let j=await h.createBinFile(s,"zkey",1,14,4194304,16777216);if(i.prime!=c.r)return b&&b.error("r1cs curve does not match powers of tau ceremony curve"),-1;let e=ao(m.length-1)+1;e<3&&(e=3);let k=2**e;if(b&&b.info("Plonk constraints: "+m.length),e>n)return b&&b.error(`circuit too big for this power of tau ceremony. ${m.length} > 2**${n}`),-1;if(!g[12])return b&&b.error("Powers of tau is not prepared."),-1;let t=new a.BigBuffer(k*d),u=g[12][0].p+(2**e-1)*d;await f.readToBuffer(t,0,k*d,u);let[E,F]=function(){let a=y.two;for(;c(a,[],e);)y.add(a,y.one);let b=y.add(a,y.one);for(;c(b,[a],e);)y.add(b,y.one);return[a,b];function c(c,d,e){let g=2**e,a=y.one;for(let f=0;f<g;f++){if(y.eq(c,a))return!0;for(let b=0;b<d.length;b++)if(y.eq(c,y.mul(d[b],a)))return!0;a=y.mul(a,y.w[e])}return!1}}(),G={};await L(3,"Additions"),globalThis.gc&&globalThis.gc(),await I(4,0,"Amap"),globalThis.gc&&globalThis.gc(),await I(5,1,"Bmap"),globalThis.gc&&globalThis.gc(),await I(6,2,"Cmap"),globalThis.gc&&globalThis.gc(),await J(7,3,"Qm"),globalThis.gc&&globalThis.gc(),await J(8,4,"Ql"),globalThis.gc&&globalThis.gc(),await J(9,5,"Qr"),globalThis.gc&&globalThis.gc(),await J(10,6,"Qo"),globalThis.gc&&globalThis.gc(),await J(11,7,"Qc"),globalThis.gc&&globalThis.gc(),await M(12,"sigma"),globalThis.gc&&globalThis.gc(),await N(13,"lagrange polynomials"),globalThis.gc&&globalThis.gc(),await h.startWriteSection(j,14);let p=new a.BigBuffer((k+6)*d);async function H(){let F=0;function G(){let a=A.slice(F,F+4);F+=4;let b=new DataView(a.buffer);return b.getUint32(0,!0)}function H(){let a=y.fromRprLE(A.slice(F,F+c.Fr.n8));return F+=c.Fr.n8,a}function f(){let b=[],a={k:c.Fr.zero},h=G();for(let d=0;d<h;d++){let e=G(),f=H();0==e?a.k=f:b.push([e,f])}let g=I(b);return a.s=g[0],a.coef=g[1],a}function I(a){if(0==a.length)return[0,c.Fr.zero];if(1==a.length)return a[0];let h=a.slice(0,a.length>>1),i=a.slice(a.length>>1),b=I(h),d=I(i),e=b[0],f=d[0],g=C++,j=c.Fr.zero,k=y.neg(b[1]),l=y.neg(d[1]),n=c.Fr.one,o=c.Fr.zero;return m.push([e,f,g,j,k,l,n,o]),B.push([e,f,b[1],d[1]]),[g,c.Fr.one]}for(let g=1;g<=D;g++){let j=g,k=0,l=0,n=c.Fr.zero,o=c.Fr.one,p=c.Fr.zero,q=c.Fr.zero,r=c.Fr.zero;m.push([j,k,l,n,o,p,q,r])}for(let e=0;e<i.nConstraints;e++){b&&e%1e4==0&&b.debug(`processing constraints: ${e}/${i.nConstraints}`);let a=f(),d=f(),h=f(),s=a.s,t=d.s,u=h.s,v=c.Fr.mul(a.coef,d.coef),w=c.Fr.mul(a.coef,d.k),x=c.Fr.mul(a.k,d.coef),z=c.Fr.neg(h.coef),E=c.Fr.sub(c.Fr.mul(a.k,d.k),h.k);m.push([s,t,u,v,w,x,z,E])}}async function I(c,d,e){await h.startWriteSection(j,c);for(let a=0;a<m.length;a++)await j.writeULE32(m[a][d]),b&&a%1e6==0&&b.debug(`writing ${e}: ${a}/${m.length}`);await h.endWriteSection(j)}async function J(g,i,f){let e=new a.BigBuffer(k*z);for(let d=0;d<m.length;d++)e.set(m[d][i],d*z),b&&d%1e6==0&&b.debug(`writing ${f}: ${d}/${m.length}`);await h.startWriteSection(j,g),await K(e),await h.endWriteSection(j),e=await y.batchFromMontgomery(e),G[f]=await c.G1.multiExpAffine(t,e,b,"multiexp "+f)}async function K(d){let b=await y.ifft(d),c=new a.BigBuffer(k*z*4);c.set(b,0);let e=await y.fft(c);await j.write(b),await j.write(e)}async function L(g,i){await h.startWriteSection(j,g);let d=new Uint8Array(8+2*z),f=new DataView(d.buffer);for(let c=0;c<B.length;c++){let e=B[c],a=0;f.setUint32(a,e[0],!0),a+=4,f.setUint32(a,e[1],!0),a+=4,d.set(e[2],a),a+=z,d.set(e[3],a),a+=z,await j.write(d),b&&c%1e6==0&&b.debug(`writing ${i}: ${c}/${B.length}`)}await h.endWriteSection(j)}async function M(r,o){let g=new a.BigBuffer(z*k*3),s=new bl(C),p=new bl(C),q=y.one;for(let d=0;d<k;d++)d<m.length?(u(m[d][0],d),u(m[d][1],k+d),u(m[d][2],2*k+d)):(u(0,d),u(0,k+d),u(0,2*k+d)),q=y.mul(q,y.w[e]),b&&d%1e6==0&&b.debug(`writing ${o} phase1: ${d}/${m.length}`);for(let f=0;f<C;f++)void 0!==p[f]?g.set(s[f],p[f]*z):console.log("Variable not used"),b&&f%1e6==0&&b.debug(`writing ${o} phase2: ${f}/${C}`);globalThis.gc&&globalThis.gc(),await h.startWriteSection(j,r);let i=g.slice(0,k*z);await K(i),globalThis.gc&&globalThis.gc();let l=g.slice(k*z,k*z*2);await K(l),globalThis.gc&&globalThis.gc();let n=g.slice(k*z*2,k*z*3);function u(a,b){void 0===s[a]?p[a]=b:g.set(s[a],b*z);let c;c=b<k?q:b<2*k?y.mul(q,E):y.mul(q,F),s[a]=c}await K(n),globalThis.gc&&globalThis.gc(),await h.endWriteSection(j),i=await y.batchFromMontgomery(i),l=await y.batchFromMontgomery(l),n=await y.batchFromMontgomery(n),G.S1=await c.G1.multiExpAffine(t,i,b,"multiexp S1"),globalThis.gc&&globalThis.gc(),G.S2=await c.G1.multiExpAffine(t,l,b,"multiexp S2"),globalThis.gc&&globalThis.gc(),G.S3=await c.G1.multiExpAffine(t,n,b,"multiexp S3"),globalThis.gc&&globalThis.gc()}async function N(f,g){await h.startWriteSection(j,f);let d=Math.max(D,1);for(let c=0;c<d;c++){let e=new a.BigBuffer(k*z);e.set(y.one,c*z),await K(e),b&&b.debug(`writing ${g} ${c}/${d}`)}await h.endWriteSection(j)}async function v(){await h.startWriteSection(j,1),await j.writeULE32(2),await h.endWriteSection(j),await h.startWriteSection(j,2);let b=c.q,d=(Math.floor((a.Scalar.bitLength(b)-1)/64)+1)*8,e=c.r,i=(Math.floor((a.Scalar.bitLength(e)-1)/64)+1)*8;await j.writeULE32(d),await h.writeBigInt(j,b,d),await j.writeULE32(i),await h.writeBigInt(j,e,i),await j.writeULE32(C),await j.writeULE32(D),await j.writeULE32(k),await j.writeULE32(B.length),await j.writeULE32(m.length),await j.write(E),await j.write(F),await j.write(w.toAffine(G.Qm)),await j.write(w.toAffine(G.Ql)),await j.write(w.toAffine(G.Qr)),await j.write(w.toAffine(G.Qo)),await j.write(w.toAffine(G.Qc)),await j.write(w.toAffine(G.S1)),await j.write(w.toAffine(G.S2)),await j.write(w.toAffine(G.S3));let l;await j.write(await f.read(x,g[3][0].p+x)),await h.endWriteSection(j)}await f.readToBuffer(p,0,(k+6)*d,g[2][0].p),await j.write(p),await h.endWriteSection(j),globalThis.gc&&globalThis.gc(),await v(),await j.close(),await l.close(),await f.close(),b&&b.info("Setup Finished")}let{stringifyBigInts:bq}=a.utils,{keccak256:br}=f.default;async function Y(s,t,p){let{fd:m,sections:q}=await af.readBinFile(t,"wtns",2,33554432,8388608),n=await aP(m,q),{fd:g,sections:h}=await af.readBinFile(s,"zkey",2,33554432,8388608),c=await aD(g,h);if("plonk"!=c.protocol)throw Error("zkey file is not plonk");if(!a.Scalar.eq(c.r,n.q))throw Error("Curve of the witness does not match the curve of the proving key");if(n.nWitness!=c.nVars-c.nAdditions)throw Error(`Invalid witness length. Circuit: ${c.nVars}, witness: ${n.nWitness}, ${c.nAdditions}`);let j=c.curve,e=j.Fr,f=j.G1,d=j.Fr.n8;p&&p.debug("Reading Wtns");let r=await af.readSection(m,q,2);r.set(e.zero,0);let x=new a.BigBuffer(d*c.nAdditions);await O();let y,z,A,B,C,D,E,F,G,H,I,J,K,L,b={},o=new a.BigBuffer(c.domainSize*d*12),i=h[12][0].p+c.domainSize*d;await g.readToBuffer(o,0,c.domainSize*d*4,i),i+=c.domainSize*d*5,await g.readToBuffer(o,c.domainSize*d*4,c.domainSize*d*4,i),i+=c.domainSize*d*5,await g.readToBuffer(o,c.domainSize*d*8,c.domainSize*d*4,i);let u=new a.BigBuffer(c.domainSize*d);await g.readToBuffer(u,0,c.domainSize*d,h[12][0].p);let v=new a.BigBuffer(c.domainSize*d);await g.readToBuffer(v,0,c.domainSize*d,h[12][0].p+5*c.domainSize*d);let M=await af.readSection(g,h,14),N={};await S(),await T(),await U(),await V(),await W(),b.protocol="plonk",b.curve=j.name,await g.close(),await m.close();let k=[];for(let l=1;l<=c.nPublic;l++){let w=r.slice(l*e.n8,l*e.n8+e.n8);k.push(a.Scalar.fromRprLE(w))}return b.A=f.toObject(b.A),b.B=f.toObject(b.B),b.C=f.toObject(b.C),b.Z=f.toObject(b.Z),b.T1=f.toObject(b.T1),b.T2=f.toObject(b.T2),b.T3=f.toObject(b.T3),b.eval_a=e.toObject(b.eval_a),b.eval_b=e.toObject(b.eval_b),b.eval_c=e.toObject(b.eval_c),b.eval_s1=e.toObject(b.eval_s1),b.eval_s2=e.toObject(b.eval_s2),b.eval_zw=e.toObject(b.eval_zw),b.eval_t=e.toObject(b.eval_t),b.eval_r=e.toObject(b.eval_r),b.Wxi=f.toObject(b.Wxi),b.Wxiw=f.toObject(b.Wxiw),delete b.eval_t,b=bq(b),k=bq(k),{proof:b,publicSignals:k};async function O(){let e=await af.readSection(g,h,3),b=8+2*j.Fr.n8;for(let a=0;a<c.nAdditions;a++){let f=Q(e,a*b),i=Q(e,a*b+4),k=e.slice(a*b+8,a*b+8+d),l=e.slice(a*b+8+d,a*b+8+2*d),m=R(f),n=R(i),o=j.Fr.add(j.Fr.mul(k,m),j.Fr.mul(l,n));x.set(o,d*a)}}async function P(){let f=new a.BigBuffer(c.domainSize*d),i=new a.BigBuffer(c.domainSize*d),j=new a.BigBuffer(c.domainSize*d),k=await af.readSection(g,h,4),l=await af.readSection(g,h,5),m=await af.readSection(g,h,6);for(let b=0;b<c.nConstrains;b++){let n=Q(k,4*b);f.set(R(n),b*d);let o=Q(l,4*b);i.set(R(o),b*d);let p=Q(m,4*b);j.set(R(p),b*d)}return f=await e.batchToMontgomery(f),i=await e.batchToMontgomery(i),j=await e.batchToMontgomery(j),[f,i,j]}function Q(c,b){let a=c.slice(b,b+4),d=new DataView(a.buffer,a.byteOffset,a.byteLength);return d.getUint32(0,!0)}function R(a){return a<c.nVars-c.nAdditions?r.slice(a*d,a*d+d):a<c.nVars?x.slice((a-(c.nVars-c.nAdditions))*d,(a-(c.nVars-c.nAdditions))*d+d):j.Fr.zero}async function S(){N.b=[];for(let a=1;a<=9;a++)N.b[a]=j.Fr.random();[y,z,A]=await P(),[G,C]=await _(y,[N.b[2],N.b[1]]),[H,D]=await _(z,[N.b[4],N.b[3]]),[I,E]=await _(A,[N.b[6],N.b[5]]),b.A=await $(G,"multiexp A"),b.B=await $(H,"multiexp B"),b.C=await $(I,"multiexp C")}async function T(){let k=new Uint8Array(c.nPublic*d+6*f.F.n8);for(let l=0;l<c.nPublic;l++)e.toRprBE(k,l*d,y.slice(l*d,(l+1)*d));f.toRprUncompressed(k,c.nPublic*d+0,b.A),f.toRprUncompressed(k,c.nPublic*d+2*f.F.n8,b.B),f.toRprUncompressed(k,c.nPublic*d+4*f.F.n8,b.C),N.beta=X(k),p&&p.debug("beta: "+e.toString(N.beta));let v=new Uint8Array(d);e.toRprBE(v,0,N.beta),N.gamma=X(v),p&&p.debug("gamma: "+e.toString(N.gamma));let h=new a.BigBuffer(e.n8*c.domainSize),j=new a.BigBuffer(e.n8*c.domainSize);h.set(e.one,0),j.set(e.one,0);let m=e.one;for(let g=0;g<c.domainSize;g++){let n=y.slice(g*d,(g+1)*d);n=e.add(n,e.mul(N.beta,m)),n=e.add(n,N.gamma);let q=z.slice(g*d,(g+1)*d);q=e.add(q,e.mul(c.k1,e.mul(N.beta,m))),q=e.add(q,N.gamma);let r=A.slice(g*d,(g+1)*d);r=e.add(r,e.mul(c.k2,e.mul(N.beta,m))),r=e.add(r,N.gamma);let w=e.mul(n,e.mul(q,r)),s=y.slice(g*d,(g+1)*d);s=e.add(s,e.mul(o.slice(g*d*4,g*d*4+d),N.beta)),s=e.add(s,N.gamma);let t=z.slice(g*d,(g+1)*d);t=e.add(t,e.mul(o.slice((c.domainSize+g)*4*d,(c.domainSize+g)*4*d+d),N.beta)),t=e.add(t,N.gamma);let u=A.slice(g*d,(g+1)*d);u=e.add(u,e.mul(o.slice((2*c.domainSize+g)*4*d,(2*c.domainSize+g)*4*d+d),N.beta)),u=e.add(u,N.gamma);let x=e.mul(s,e.mul(t,u));h.set(e.mul(h.slice(g*d,(g+1)*d),w),(g+1)%c.domainSize*d),j.set(e.mul(j.slice(g*d,(g+1)*d),x),(g+1)%c.domainSize*d),m=e.mul(m,e.w[c.power])}j=await e.batchInverse(j);for(let i=0;i<c.domainSize;i++)h.set(e.mul(h.slice(i*d,(i+1)*d),j.slice(i*d,(i+1)*d)),i*d);if(!e.eq(h.slice(0,d),e.one))throw Error("Copy constraints does not match");B=h,[J,F]=await _(B,[N.b[9],N.b[8],N.b[7]]),b.Z=await $(J,"multiexp Z")}async function U(){p&&p.debug("phse3: Reading QM4");let V=new a.BigBuffer(4*c.domainSize*d);await g.readToBuffer(V,0,c.domainSize*d*4,h[7][0].p+c.domainSize*d),p&&p.debug("phse3: Reading QL4");let W=new a.BigBuffer(4*c.domainSize*d);await g.readToBuffer(W,0,c.domainSize*d*4,h[8][0].p+c.domainSize*d),p&&p.debug("phse3: Reading QR4");let Y=new a.BigBuffer(4*c.domainSize*d);await g.readToBuffer(Y,0,c.domainSize*d*4,h[9][0].p+c.domainSize*d),p&&p.debug("phse3: Reading QO4");let Z=new a.BigBuffer(4*c.domainSize*d);await g.readToBuffer(Z,0,c.domainSize*d*4,h[10][0].p+c.domainSize*d),p&&p.debug("phse3: Reading QC4");let _=new a.BigBuffer(4*c.domainSize*d);await g.readToBuffer(_,0,c.domainSize*d*4,h[11][0].p+c.domainSize*d);let J=await af.readSection(g,h,13),aa=new Uint8Array(2*f.F.n8);f.toRprUncompressed(aa,0,b.Z),N.alpha=X(aa),p&&p.debug("alpha: "+e.toString(N.alpha));let aA=[e.zero,e.add(e.e(-1),e.w[2]),e.e(-2),e.sub(e.e(-1),e.w[2]),],aB=[e.zero,e.add(e.zero,e.mul(e.e(-2),e.w[2])),e.e(4),e.sub(e.zero,e.mul(e.e(-2),e.w[2])),],aC=[e.zero,e.add(e.e(2),e.mul(e.e(2),e.w[2])),e.e(-8),e.sub(e.e(2),e.mul(e.e(2),e.w[2])),],ab=new a.BigBuffer(4*c.domainSize*d),ac=new a.BigBuffer(4*c.domainSize*d),l=e.one;for(let i=0;i<4*c.domainSize;i++){i%4096==0&&p&&p.debug(`calculating t ${i}/${4*c.domainSize}`);let B=C.slice(i*d,i*d+d),G=D.slice(i*d,i*d+d),L=E.slice(i*d,i*d+d),ad=F.slice(i*d,i*d+d),an=F.slice((i+4*c.domainSize+4)%(4*c.domainSize)*d,(i+4*c.domainSize+4)%(4*c.domainSize)*d+d),ae=V.slice(i*d,i*d+d),ag=W.slice(i*d,i*d+d),ah=Y.slice(i*d,i*d+d),ai=Z.slice(i*d,i*d+d),ao=_.slice(i*d,i*d+d),ap=o.slice(i*d,i*d+d),aq=o.slice((i+4*c.domainSize)*d,(i+4*c.domainSize)*d+d),ar=o.slice((i+8*c.domainSize)*d,(i+8*c.domainSize)*d+d),H=e.add(N.b[2],e.mul(N.b[1],l)),I=e.add(N.b[4],e.mul(N.b[3],l)),M=e.add(N.b[6],e.mul(N.b[5],l)),as=e.square(l),aj=e.add(e.add(e.mul(N.b[7],as),e.mul(N.b[8],l)),N.b[9]),ak=e.mul(l,e.w[c.power]),at=e.square(ak),au=e.add(e.add(e.mul(N.b[7],at),e.mul(N.b[8],ak)),N.b[9]),O=e.zero;for(let r=0;r<c.nPublic;r++)O=e.sub(O,e.mul(J.slice((5*r*c.domainSize+c.domainSize+i)*d,(5*r*c.domainSize+c.domainSize+i+1)*d),y.slice(r*d,(r+1)*d)));let[j,m]=aD(B,G,H,I,i%4);j=e.mul(j,ae),m=e.mul(m,ae),j=e.add(j,e.mul(B,ag)),m=e.add(m,e.mul(H,ag)),j=e.add(j,e.mul(G,ah)),m=e.add(m,e.mul(I,ah)),j=e.add(j,e.mul(L,ai)),m=e.add(m,e.mul(M,ai)),j=e.add(j,O),j=e.add(j,ao);let P=e.mul(N.beta,l),s=B;s=e.add(s,P),s=e.add(s,N.gamma);let t=G;t=e.add(t,e.mul(P,c.k1)),t=e.add(t,N.gamma);let u=L;u=e.add(u,e.mul(P,c.k2)),u=e.add(u,N.gamma);let av=ad,[Q,R]=aE(s,t,u,av,H,I,M,aj,i%4);Q=e.mul(Q,N.alpha),R=e.mul(R,N.alpha);let v=B;v=e.add(v,e.mul(N.beta,ap)),v=e.add(v,N.gamma);let w=G;w=e.add(w,e.mul(N.beta,aq)),w=e.add(w,N.gamma);let x=L;x=e.add(x,e.mul(N.beta,ar)),x=e.add(x,N.gamma);let aw=an,[S,T]=aE(v,w,x,aw,H,I,M,au,i%4);S=e.mul(S,N.alpha),T=e.mul(T,N.alpha);let z=e.sub(ad,e.one);z=e.mul(z,J.slice((c.domainSize+i)*d,(c.domainSize+i+1)*d)),z=e.mul(z,e.mul(N.alpha,N.alpha));let U=e.mul(aj,J.slice((c.domainSize+i)*d,(c.domainSize+i+1)*d));U=e.mul(U,e.mul(N.alpha,N.alpha));let ax=e.add(e.sub(e.add(j,Q),S),z),ay=e.add(e.sub(e.add(m,R),T),U);ab.set(ax,i*d),ac.set(ay,i*d),l=e.mul(l,e.w[c.power+2])}p&&p.debug("ifft T");let k=await e.ifft(ab);p&&p.debug("dividing T/Z");for(let A=0;A<c.domainSize;A++)k.set(e.neg(k.slice(A*d,A*d+d)),A*d);for(let n=c.domainSize;n<4*c.domainSize;n++){let al=e.sub(k.slice((n-c.domainSize)*d,(n-c.domainSize)*d+d),k.slice(n*d,n*d+d));if(k.set(al,n*d),n>3*c.domainSize-4&&!e.isZero(al))throw Error("T Polynomial is not divisible")}p&&p.debug("ifft Tz");let az=await e.ifft(ac);for(let q=0;q<4*c.domainSize;q++){let am=az.slice(q*d,(q+1)*d);if(q>3*c.domainSize+5){if(!e.isZero(am))throw Error("Tz Polynomial is not well calculated")}else k.set(e.add(k.slice(q*d,(q+1)*d),am),q*d)}function aD(b,c,d,f,g){let h,a,i=e.mul(b,c),j=e.mul(b,f),k=e.mul(d,c),l=e.mul(d,f);h=i;let m;return a=e.add(j,k),g&&(a=e.add(a,e.mul(aA[g],l))),[h,a]}function aE(o,p,q,r,s,t,u,v,f){let w,b,g=e.mul(o,p),h=e.mul(o,t),i=e.mul(s,p),j=e.mul(s,t),k=e.mul(q,r),l=e.mul(q,v),m=e.mul(u,r),n=e.mul(u,v);w=e.mul(g,k);let c=e.mul(i,k);c=e.add(c,e.mul(h,k)),c=e.add(c,e.mul(g,m)),c=e.add(c,e.mul(g,l));let a=e.mul(j,k);a=e.add(a,e.mul(i,m)),a=e.add(a,e.mul(i,l)),a=e.add(a,e.mul(h,m)),a=e.add(a,e.mul(h,l)),a=e.add(a,e.mul(g,n));let d=e.mul(h,n);d=e.add(d,e.mul(i,n)),d=e.add(d,e.mul(j,l)),d=e.add(d,e.mul(j,m));let x=e.mul(j,n);return b=c,f&&(b=e.add(b,e.mul(aA[f],a)),b=e.add(b,e.mul(aB[f],d)),b=e.add(b,e.mul(aC[f],x))),[w,b]}K=k.slice(0,(3*c.domainSize+6)*d),b.T1=await $(k.slice(0,c.domainSize*d),"multiexp T1"),b.T2=await $(k.slice(c.domainSize*d,2*c.domainSize*d),"multiexp T2"),b.T3=await $(k.slice(2*c.domainSize*d,(3*c.domainSize+6)*d),"multiexp T3")}async function V(){let t=new a.BigBuffer(c.domainSize*d);await g.readToBuffer(t,0,c.domainSize*d,h[7][0].p);let w=new a.BigBuffer(c.domainSize*d);await g.readToBuffer(w,0,c.domainSize*d,h[8][0].p);let x=new a.BigBuffer(c.domainSize*d);await g.readToBuffer(x,0,c.domainSize*d,h[9][0].p);let y=new a.BigBuffer(c.domainSize*d);await g.readToBuffer(y,0,c.domainSize*d,h[10][0].p);let z=new a.BigBuffer(c.domainSize*d);await g.readToBuffer(z,0,c.domainSize*d,h[11][0].p);let A=new a.BigBuffer(c.domainSize*d);await g.readToBuffer(A,0,c.domainSize*d,h[12][0].p+10*c.domainSize*d);let r=new Uint8Array(6*f.F.n8);f.toRprUncompressed(r,0,b.T1),f.toRprUncompressed(r,2*f.F.n8,b.T2),f.toRprUncompressed(r,4*f.F.n8,b.T3),N.xi=X(r),p&&p.debug("xi: "+e.toString(N.xi)),b.eval_a=Y(G,N.xi),b.eval_b=Y(H,N.xi),b.eval_c=Y(I,N.xi),b.eval_s1=Y(u,N.xi),b.eval_s2=Y(v,N.xi),b.eval_t=Y(K,N.xi),b.eval_zw=Y(J,e.mul(N.xi,e.w[c.power]));let C=e.mul(b.eval_a,b.eval_b),l=b.eval_a,s=e.mul(N.beta,N.xi);l=e.add(l,s),l=e.add(l,N.gamma);let m=b.eval_b;m=e.add(m,e.mul(s,c.k1)),m=e.add(m,N.gamma);let n=b.eval_c;n=e.add(n,e.mul(s,c.k2)),n=e.add(n,N.gamma);let D=e.mul(e.mul(e.mul(l,m),n),N.alpha),o=b.eval_a;o=e.add(o,e.mul(N.beta,b.eval_s1)),o=e.add(o,N.gamma);let q=b.eval_b;q=e.add(q,e.mul(N.beta,b.eval_s2)),q=e.add(q,N.gamma);let k=e.mul(o,q);k=e.mul(k,N.beta),k=e.mul(k,b.eval_zw),k=e.mul(k,N.alpha),N.xim=N.xi;for(let B=0;B<c.power;B++)N.xim=e.mul(N.xim,N.xim);let E=e.div(e.sub(N.xim,e.one),e.mul(e.sub(N.xi,e.one),e.e(c.domainSize))),F=e.mul(E,e.mul(N.alpha,N.alpha)),M=k,O=e.add(D,F);L=new a.BigBuffer((c.domainSize+3)*d);for(let i=0;i<c.domainSize+3;i++){let j=e.mul(O,J.slice(i*d,(i+1)*d));i<c.domainSize&&(j=e.add(j,e.mul(C,t.slice(i*d,(i+1)*d))),j=e.add(j,e.mul(b.eval_a,w.slice(i*d,(i+1)*d))),j=e.add(j,e.mul(b.eval_b,x.slice(i*d,(i+1)*d))),j=e.add(j,e.mul(b.eval_c,y.slice(i*d,(i+1)*d))),j=e.add(j,z.slice(i*d,(i+1)*d)),j=e.sub(j,e.mul(M,A.slice(i*d,(i+1)*d)))),L.set(j,i*d)}b.eval_r=Y(L,N.xi)}async function W(){let i=new Uint8Array(7*d);e.toRprBE(i,0,b.eval_a),e.toRprBE(i,d,b.eval_b),e.toRprBE(i,2*d,b.eval_c),e.toRprBE(i,3*d,b.eval_s1),e.toRprBE(i,4*d,b.eval_s2),e.toRprBE(i,5*d,b.eval_zw),e.toRprBE(i,6*d,b.eval_r),N.v=[],N.v[1]=X(i),p&&p.debug("v: "+e.toString(N.v[1]));for(let m=2;m<=6;m++)N.v[m]=e.mul(N.v[m-1],N.v[1]);let j=new a.BigBuffer((c.domainSize+6)*d),n=e.mul(N.xim,N.xim);for(let f=0;f<c.domainSize+6;f++){let g=e.zero;g=e.add(g,e.mul(n,K.slice((2*c.domainSize+f)*d,(2*c.domainSize+f+1)*d))),f<c.domainSize+3&&(g=e.add(g,e.mul(N.v[1],L.slice(f*d,(f+1)*d)))),f<c.domainSize+2&&(g=e.add(g,e.mul(N.v[2],G.slice(f*d,(f+1)*d))),g=e.add(g,e.mul(N.v[3],H.slice(f*d,(f+1)*d))),g=e.add(g,e.mul(N.v[4],I.slice(f*d,(f+1)*d)))),f<c.domainSize&&(g=e.add(g,K.slice(f*d,(f+1)*d)),g=e.add(g,e.mul(N.xim,K.slice((c.domainSize+f)*d,(c.domainSize+f+1)*d))),g=e.add(g,e.mul(N.v[5],u.slice(f*d,(f+1)*d))),g=e.add(g,e.mul(N.v[6],v.slice(f*d,(f+1)*d)))),j.set(g,f*d)}let h=j.slice(0,d);h=e.sub(h,b.eval_t),h=e.sub(h,e.mul(N.v[1],b.eval_r)),h=e.sub(h,e.mul(N.v[2],b.eval_a)),h=e.sub(h,e.mul(N.v[3],b.eval_b)),h=e.sub(h,e.mul(N.v[4],b.eval_c)),h=e.sub(h,e.mul(N.v[5],b.eval_s1)),h=e.sub(h,e.mul(N.v[6],b.eval_s2)),j.set(h,0),j=Z(j,N.xi),b.Wxi=await $(j,"multiexp Wxi");let k=new a.BigBuffer((c.domainSize+3)*d);for(let l=0;l<c.domainSize+3;l++){let o=J.slice(l*d,(l+1)*d);k.set(o,l*d)}h=k.slice(0,d),h=e.sub(h,b.eval_zw),k.set(h,0),k=Z(k,e.mul(N.xi,e.w[c.power])),b.Wxiw=await $(k,"multiexp Wxiw")}function X(b){let c=a.Scalar.fromRprBE(new Uint8Array(br.arrayBuffer(b)));return e.e(c)}function Y(c,g){let a=c.byteLength/d;if(0==a)return e.zero;let f=c.slice((a-1)*d,a*d);for(let b=a-2;b>=0;b--)f=e.add(e.mul(f,g),c.slice(b*d,(b+1)*d));return f}function Z(g,h){let c=g.byteLength/d,f=new a.BigBuffer(c*d);f.set(e.zero,(c-1)*d),f.set(g.slice((c-1)*d,c*d),(c-2)*d);for(let b=c-3;b>=0;b--)f.set(e.add(g.slice((b+1)*d,(b+2)*d),e.mul(h,f.slice((b+1)*d,(b+2)*d))),b*d);if(!e.eq(g.slice(0,d),e.mul(e.neg(h),f.slice(0,d))))throw Error("Polinomial does not divide");return f}async function $(a,b){let c=a.byteLength/d,e=M.slice(0,c*j.G1.F.n8*2),f=await j.Fr.batchFromMontgomery(a),g=await j.G1.multiExpAffine(e,f,p,b);return j.G1.toAffine(g)}async function _(j,f){f=f||[];let h=await e.ifft(j),i=new a.BigBuffer(d*c.domainSize*4);i.set(h,0);let g=new a.BigBuffer(d*(c.domainSize+f.length));g.set(h,0);for(let b=0;b<f.length;b++)g.set(e.add(g.slice((c.domainSize+b)*d,(c.domainSize+b+1)*d),f[b]),(c.domainSize+b)*d),g.set(e.sub(g.slice(b*d,(b+1)*d),f[b]),b*d);let k=await e.fft(i);return[g,k]}}let{unstringifyBigInts:bs}=a.utils;async function Z(b,c,d,e){let f=bs(b),a={type:"mem"};return await o(f,c,a),await Y(d,a,e)}let{unstringifyBigInts:bt}=a.utils,{keccak256:bu}=f.default;async function $(q,r,s,a){let d=bt(q),f=bt(s),i=bt(r),b=await an(d.curve),e=b.Fr,g=b.G1;if(f=bv(b,f),d=bw(b,d),!bx(b,f))return a.error("Proof is not well constructed"),!1;if(i.length!=d.nPublic)return a.error("Invalid number of public inputs"),!1;let c=by(b,f,i);a&&(a.debug("beta: "+e.toString(c.beta,16)),a.debug("gamma: "+e.toString(c.gamma,16)),a.debug("alpha: "+e.toString(c.alpha,16)),a.debug("xi: "+e.toString(c.xi,16)),a.debug("v1: "+e.toString(c.v[1],16)),a.debug("v6: "+e.toString(c.v[6],16)),a.debug("u: "+e.toString(c.u,16)));let h=bz(b,c,d);if(a){a.debug("Lagrange Evaluations: ");for(let j=1;j<h.length;j++)a.debug(`L${j}(xi)=`+e.toString(h[j],16))}if(i.length!=d.nPublic)return a.error("Number of public signals does not match with vk"),!1;let k=bB(b,i,h);a&&a.debug("Pl: "+e.toString(k,16));let l=bC(b,f,c,k,h[1]);a&&a.debug("t: "+e.toString(l,16));let m=bD(b,f,c,d,h[1]);a&&a.debug("D: "+g.toString(g.toAffine(m),16));let n=bE(b,f,c,d,m);a&&a.debug("F: "+g.toString(g.toAffine(n),16));let o=bF(b,f,c,d,l);a&&a.debug("E: "+g.toString(g.toAffine(o),16));let p=await bG(b,f,c,d,o,n);return a&&(p?a.info("OK!"):a.warn("Invalid Proof")),p}function bv(e,b){let c=e.G1,d=e.Fr,a={};return a.A=c.fromObject(b.A),a.B=c.fromObject(b.B),a.C=c.fromObject(b.C),a.Z=c.fromObject(b.Z),a.T1=c.fromObject(b.T1),a.T2=c.fromObject(b.T2),a.T3=c.fromObject(b.T3),a.eval_a=d.fromObject(b.eval_a),a.eval_b=d.fromObject(b.eval_b),a.eval_c=d.fromObject(b.eval_c),a.eval_zw=d.fromObject(b.eval_zw),a.eval_s1=d.fromObject(b.eval_s1),a.eval_s2=d.fromObject(b.eval_s2),a.eval_r=d.fromObject(b.eval_r),a.Wxi=c.fromObject(b.Wxi),a.Wxiw=c.fromObject(b.Wxiw),a}function bw(d,a){let c=d.G1,f=d.G2,e=d.Fr,b=a;return b.Qm=c.fromObject(a.Qm),b.Ql=c.fromObject(a.Ql),b.Qr=c.fromObject(a.Qr),b.Qo=c.fromObject(a.Qo),b.Qc=c.fromObject(a.Qc),b.S1=c.fromObject(a.S1),b.S2=c.fromObject(a.S2),b.S3=c.fromObject(a.S3),b.k1=e.fromObject(a.k1),b.k2=e.fromObject(a.k2),b.X_2=f.fromObject(a.X_2),b}function bx(c,a){let b=c.G1;return!!(b.isValid(a.A)&&b.isValid(a.B)&&b.isValid(a.C)&&b.isValid(a.Z)&&b.isValid(a.T1)&&b.isValid(a.T2)&&b.isValid(a.T3)&&b.isValid(a.Wxi)&&b.isValid(a.Wxiw))}function by(f,b,h){let a=f.G1,e=f.Fr,c=f.Fr.n8,d={},i=new Uint8Array(h.length*c+6*a.F.n8);for(let j=0;j<h.length;j++)e.toRprBE(i,j*c,e.e(h[j]));a.toRprUncompressed(i,h.length*c+0,b.A),a.toRprUncompressed(i,h.length*c+2*a.F.n8,b.B),a.toRprUncompressed(i,h.length*c+4*a.F.n8,b.C),d.beta=bA(f,i);let n=new Uint8Array(c);e.toRprBE(n,0,d.beta),d.gamma=bA(f,n);let o=new Uint8Array(2*a.F.n8);a.toRprUncompressed(o,0,b.Z),d.alpha=bA(f,o);let k=new Uint8Array(6*a.F.n8);a.toRprUncompressed(k,0,b.T1),a.toRprUncompressed(k,2*a.F.n8,b.T2),a.toRprUncompressed(k,4*a.F.n8,b.T3),d.xi=bA(f,k);let g=new Uint8Array(7*c);e.toRprBE(g,0,b.eval_a),e.toRprBE(g,c,b.eval_b),e.toRprBE(g,2*c,b.eval_c),e.toRprBE(g,3*c,b.eval_s1),e.toRprBE(g,4*c,b.eval_s2),e.toRprBE(g,5*c,b.eval_zw),e.toRprBE(g,6*c,b.eval_r),d.v=[],d.v[1]=bA(f,g);for(let l=2;l<=6;l++)d.v[l]=e.mul(d.v[l-1],d.v[1]);let m=new Uint8Array(4*a.F.n8);return a.toRprUncompressed(m,0,b.Wxi),a.toRprUncompressed(m,2*a.F.n8,b.Wxiw),d.u=bA(f,m),d}function bz(j,b,e){let a=j.Fr,c=b.xi,g=1;for(let h=0;h<e.power;h++)c=a.square(c),g*=2;b.xin=c,b.zh=a.sub(c,a.one);let i=[],k=a.e(g),d=a.one;for(let f=1;f<=Math.max(1,e.nPublic);f++)i[f]=a.div(a.mul(d,b.zh),a.mul(k,a.sub(b.xi,d))),d=a.mul(d,a.w[e.power]);return i}function bA(b,c){let d=a.Scalar.fromRprBE(new Uint8Array(bu.arrayBuffer(c)));return b.Fr.e(d)}function bB(e,d,f){let a=e.Fr,c=a.zero;for(let b=0;b<d.length;b++){let g=a.e(d[b]);c=a.sub(c,a.mul(g,f[b+1]))}return c}function bC(i,c,b,j,k){let a=i.Fr,d=c.eval_r;d=a.add(d,j);let e=c.eval_a;e=a.add(e,a.mul(b.beta,c.eval_s1)),e=a.add(e,b.gamma);let f=c.eval_b;f=a.add(f,a.mul(b.beta,c.eval_s2)),f=a.add(f,b.gamma);let h=c.eval_c;h=a.add(h,b.gamma);let g=a.mul(a.mul(e,f),h);g=a.mul(g,c.eval_zw),g=a.mul(g,b.alpha),d=a.sub(d,g),d=a.sub(d,a.mul(k,a.square(b.alpha)));let l=a.div(d,b.zh);return l}function bD(o,c,b,g,p){let d=o.G1,a=o.Fr,q=a.mul(a.mul(c.eval_a,c.eval_b),b.v[1]),e=d.timesFr(g.Qm,q),r=a.mul(c.eval_a,b.v[1]);e=d.add(e,d.timesFr(g.Ql,r));let s=a.mul(c.eval_b,b.v[1]);e=d.add(e,d.timesFr(g.Qr,s));let t=a.mul(c.eval_c,b.v[1]);e=d.add(e,d.timesFr(g.Qo,t)),e=d.add(e,d.timesFr(g.Qc,b.v[1]));let n=a.mul(b.beta,b.xi),i=c.eval_a;i=a.add(i,n),i=a.add(i,b.gamma);let j=c.eval_b;j=a.add(j,a.mul(n,g.k1)),j=a.add(j,b.gamma);let k=c.eval_c;k=a.add(k,a.mul(n,g.k2)),k=a.add(k,b.gamma);let h=a.mul(a.mul(i,j),k);h=a.mul(h,a.mul(b.alpha,b.v[1]));let u=a.mul(a.mul(p,a.square(b.alpha)),b.v[1]);h=a.add(h,u),h=a.add(h,b.u),e=d.add(e,d.timesFr(c.Z,h));let l=c.eval_a;l=a.add(l,a.mul(b.beta,c.eval_s1)),l=a.add(l,b.gamma);let m=c.eval_b;m=a.add(m,a.mul(b.beta,c.eval_s2)),m=a.add(m,b.gamma);let f=a.mul(l,m);return f=a.mul(f,b.alpha),f=a.mul(f,b.v[1]),f=a.mul(f,b.beta),f=a.mul(f,c.eval_zw),e=d.sub(e,d.timesFr(g.S3,f))}function bE(e,d,c,f,g){let b=e.G1,h=e.Fr,a=d.T1;return a=b.add(a,b.timesFr(d.T2,c.xin)),a=b.add(a,b.timesFr(d.T3,h.square(c.xin))),a=b.add(a,g),a=b.add(a,b.timesFr(d.A,c.v[2])),a=b.add(a,b.timesFr(d.B,c.v[3])),a=b.add(a,b.timesFr(d.C,c.v[4])),a=b.add(a,b.timesFr(f.S1,c.v[5])),a=b.add(a,b.timesFr(f.S2,c.v[6]))}function bF(e,c,d,i,g){let f=e.G1,b=e.Fr,a=g;a=b.add(a,b.mul(d.v[1],c.eval_r)),a=b.add(a,b.mul(d.v[2],c.eval_a)),a=b.add(a,b.mul(d.v[3],c.eval_b)),a=b.add(a,b.mul(d.v[4],c.eval_c)),a=b.add(a,b.mul(d.v[5],c.eval_s1)),a=b.add(a,b.mul(d.v[6],c.eval_s2)),a=b.add(a,b.mul(d.u,c.eval_zw));let h=f.timesFr(f.one,a);return h}async function bG(c,d,e,h,i,j){let a=c.G1,f=c.Fr,g=d.Wxi;g=a.add(g,a.timesFr(d.Wxiw,e.u));let b=a.timesFr(d.Wxi,e.xi),k=f.mul(f.mul(e.u,e.xi),f.w[h.power]);b=a.add(b,a.timesFr(d.Wxiw,k)),b=a.add(b,j),b=a.sub(b,i);let l=await c.pairingEq(a.neg(g),h.X_2,b,c.G2.one);return l}let{unstringifyBigInts:bH}=a.utils;function bI(a){return("0"+a.toString(16)).slice(-2)}function bJ(b){let a=b.toString(16);for(;a.length<64;)a="0"+a;return`"0x${a}"`}async function _(i,j){let c=bH(i),g=bH(j),h=await an(c.curve),a=h.G1,b=h.Fr,e="";for(let f=0;f<g.length;f++)""!=e&&(e+=","),e+=bJ(g[f]);let d=new Uint8Array(18*a.F.n8+7*b.n8);a.toRprUncompressed(d,0,a.e(c.A)),a.toRprUncompressed(d,2*a.F.n8,a.e(c.B)),a.toRprUncompressed(d,4*a.F.n8,a.e(c.C)),a.toRprUncompressed(d,6*a.F.n8,a.e(c.Z)),a.toRprUncompressed(d,8*a.F.n8,a.e(c.T1)),a.toRprUncompressed(d,10*a.F.n8,a.e(c.T2)),a.toRprUncompressed(d,12*a.F.n8,a.e(c.T3)),a.toRprUncompressed(d,14*a.F.n8,a.e(c.Wxi)),a.toRprUncompressed(d,16*a.F.n8,a.e(c.Wxiw)),b.toRprBE(d,18*a.F.n8,b.e(c.eval_a)),b.toRprBE(d,18*a.F.n8+b.n8,b.e(c.eval_b)),b.toRprBE(d,18*a.F.n8+2*b.n8,b.e(c.eval_c)),b.toRprBE(d,18*a.F.n8+3*b.n8,b.e(c.eval_s1)),b.toRprBE(d,18*a.F.n8+4*b.n8,b.e(c.eval_s2)),b.toRprBE(d,18*a.F.n8+5*b.n8,b.e(c.eval_zw)),b.toRprBE(d,18*a.F.n8+6*b.n8,b.e(c.eval_r));let k=Array.from(d).map(bI).join(""),l="0x"+k+",["+e+"]";return l}var aa=Object.freeze({__proto__:null,setup:X,fullProve:Z,prove:Y,verify:$,exportSolidityCallData:_});c.groth16=s,c.plonk=aa,c.powersOfTau=E,c.r1cs=H,c.wtns=K,c.zKey=W}}])